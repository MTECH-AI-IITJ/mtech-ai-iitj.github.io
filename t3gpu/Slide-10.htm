<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=Generator content="Microsoft Word 15 (filtered)">
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Helvetica;
	panose-1:2 11 6 4 2 2 2 2 2 4;}
@font-face
	{font-family:Courier;
	panose-1:2 7 4 9 2 2 5 2 4 4;}
@font-face
	{font-family:"Tms Rmn";
	panose-1:2 2 6 3 4 5 5 2 3 4;}
@font-face
	{font-family:Helv;
	panose-1:2 11 6 4 2 2 2 3 2 4;}
@font-face
	{font-family:"New York";
	panose-1:2 4 5 3 6 5 6 2 3 4;}
@font-face
	{font-family:System;
	panose-1:0 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"MS Mincho";
	panose-1:2 2 6 9 4 2 5 8 3 4;}
@font-face
	{font-family:Batang;
	panose-1:2 3 6 0 0 1 1 1 1 1;}
@font-face
	{font-family:SimSun;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:PMingLiU;
	panose-1:2 1 6 1 0 1 1 1 1 1;}
@font-face
	{font-family:"MS Gothic";
	panose-1:2 11 6 9 7 2 5 8 2 4;}
@font-face
	{font-family:Dotum;
	panose-1:2 11 6 0 0 1 1 1 1 1;}
@font-face
	{font-family:SimHei;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:MingLiU;
	panose-1:2 1 6 9 0 1 1 1 1 1;}
@font-face
	{font-family:Mincho;
	panose-1:2 2 6 9 4 3 5 8 3 5;}
@font-face
	{font-family:Gulim;
	panose-1:2 11 6 0 0 1 1 1 1 1;}
@font-face
	{font-family:Century;
	panose-1:2 4 6 4 5 5 5 2 3 4;}
@font-face
	{font-family:"Angsana New";
	panose-1:2 2 6 3 5 4 5 2 3 4;}
@font-face
	{font-family:"Cordia New";
	panose-1:2 11 3 4 2 2 2 2 2 4;}
@font-face
	{font-family:Mangal;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Latha;
	panose-1:2 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Sylfaen;
	panose-1:1 10 5 2 5 3 6 3 3 3;}
@font-face
	{font-family:Vrinda;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Raavi;
	panose-1:2 0 5 0 0 0 0 0 0 0;}
@font-face
	{font-family:Shruti;
	panose-1:2 0 5 0 0 0 0 0 0 0;}
@font-face
	{font-family:Sendnya;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Gautami;
	panose-1:2 0 5 0 0 0 0 0 0 0;}
@font-face
	{font-family:Tunga;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:"Estrangelo Edessa";
	panose-1:0 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"Cambria Math";
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:"Yu Gothic";
	panose-1:2 11 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:DengXian;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:Calibri;
	panose-1:2 15 5 2 2 2 4 3 2 4;}
@font-face
	{font-family:"Calibri Light";
	panose-1:2 15 3 2 2 2 4 3 2 4;}
@font-face
	{font-family:"Palatino Linotype";
	panose-1:2 4 5 2 5 5 5 3 3 4;}
@font-face
	{font-family:Verdana;
	panose-1:2 11 6 4 3 5 4 4 2 4;}
@font-face
	{font-family:"Arial Unicode MS";
	panose-1:2 11 6 4 2 2 2 2 2 4;}
@font-face
	{font-family:Aptos;}
@font-face
	{font-family:"Aptos Display";}
@font-face
	{font-family:"Segoe UI Emoji";
	panose-1:2 11 5 2 4 2 4 2 2 3;}
@font-face
	{font-family:Consolas;
	panose-1:2 11 6 9 2 2 4 3 2 4;}
@font-face
	{font-family:"Segoe UI";
	panose-1:2 11 5 2 4 2 4 2 2 3;}
@font-face
	{font-family:"Segoe UI Symbol";
	panose-1:2 11 5 2 4 2 4 2 2 3;}
@font-face
	{font-family:"var\(--font-ibm-plex-mono\)";
	panose-1:0 0 0 0 0 0 0 0 0 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:0in;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Aptos",sans-serif;}
h1
	{mso-style-link:"Heading 1 Char";
	margin-top:.25in;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:0in;
	line-height:115%;
	page-break-after:avoid;
	font-size:20.0pt;
	font-family:"Aptos Display",sans-serif;
	color:#0F4761;
	font-weight:normal;}
h2
	{mso-style-link:"Heading 2 Char";
	margin-top:8.0pt;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:0in;
	line-height:115%;
	page-break-after:avoid;
	font-size:16.0pt;
	font-family:"Aptos Display",sans-serif;
	color:#0F4761;
	font-weight:normal;}
h3
	{mso-style-link:"Heading 3 Char";
	margin-top:8.0pt;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:0in;
	line-height:115%;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:"Aptos",sans-serif;
	color:#0F4761;
	font-weight:normal;}
h4
	{mso-style-link:"Heading 4 Char";
	margin-top:4.0pt;
	margin-right:0in;
	margin-bottom:2.0pt;
	margin-left:0in;
	line-height:115%;
	page-break-after:avoid;
	font-size:12.0pt;
	font-family:"Aptos",sans-serif;
	color:#0F4761;
	font-weight:normal;
	font-style:italic;}
h5
	{mso-style-link:"Heading 5 Char";
	margin-top:4.0pt;
	margin-right:0in;
	margin-bottom:2.0pt;
	margin-left:0in;
	line-height:115%;
	page-break-after:avoid;
	font-size:12.0pt;
	font-family:"Aptos",sans-serif;
	color:#0F4761;
	font-weight:normal;}
h6
	{mso-style-link:"Heading 6 Char";
	margin-top:2.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	line-height:115%;
	page-break-after:avoid;
	font-size:12.0pt;
	font-family:"Aptos",sans-serif;
	color:#595959;
	font-weight:normal;
	font-style:italic;}
p.MsoHeading7, li.MsoHeading7, div.MsoHeading7
	{mso-style-link:"Heading 7 Char";
	margin-top:2.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	line-height:115%;
	page-break-after:avoid;
	font-size:12.0pt;
	font-family:"Aptos",sans-serif;
	color:#595959;}
p.MsoHeading8, li.MsoHeading8, div.MsoHeading8
	{mso-style-link:"Heading 8 Char";
	margin:0in;
	line-height:115%;
	page-break-after:avoid;
	font-size:12.0pt;
	font-family:"Aptos",sans-serif;
	color:#272727;
	font-style:italic;}
p.MsoHeading9, li.MsoHeading9, div.MsoHeading9
	{mso-style-link:"Heading 9 Char";
	margin:0in;
	line-height:115%;
	page-break-after:avoid;
	font-size:12.0pt;
	font-family:"Aptos",sans-serif;
	color:#272727;}
p.MsoTitle, li.MsoTitle, div.MsoTitle
	{mso-style-link:"Title Char";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:0in;
	font-size:28.0pt;
	font-family:"Aptos Display",sans-serif;
	letter-spacing:-.5pt;}
p.MsoTitleCxSpFirst, li.MsoTitleCxSpFirst, div.MsoTitleCxSpFirst
	{mso-style-link:"Title Char";
	margin:0in;
	font-size:28.0pt;
	font-family:"Aptos Display",sans-serif;
	letter-spacing:-.5pt;}
p.MsoTitleCxSpMiddle, li.MsoTitleCxSpMiddle, div.MsoTitleCxSpMiddle
	{mso-style-link:"Title Char";
	margin:0in;
	font-size:28.0pt;
	font-family:"Aptos Display",sans-serif;
	letter-spacing:-.5pt;}
p.MsoTitleCxSpLast, li.MsoTitleCxSpLast, div.MsoTitleCxSpLast
	{mso-style-link:"Title Char";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:4.0pt;
	margin-left:0in;
	font-size:28.0pt;
	font-family:"Aptos Display",sans-serif;
	letter-spacing:-.5pt;}
p.MsoSubtitle, li.MsoSubtitle, div.MsoSubtitle
	{mso-style-link:"Subtitle Char";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:0in;
	line-height:115%;
	font-size:14.0pt;
	font-family:"Aptos",sans-serif;
	color:#595959;
	letter-spacing:.75pt;}
p
	{margin-right:0in;
	margin-left:0in;
	font-size:12.0pt;
	font-family:"Times New Roman",serif;}
code
	{font-family:"Courier New";}
pre
	{mso-style-link:"HTML Preformatted Char";
	margin:0in;
	font-size:10.0pt;
	font-family:"Courier New";}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:.5in;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Aptos",sans-serif;}
p.MsoListParagraphCxSpFirst, li.MsoListParagraphCxSpFirst, div.MsoListParagraphCxSpFirst
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Aptos",sans-serif;}
p.MsoListParagraphCxSpMiddle, li.MsoListParagraphCxSpMiddle, div.MsoListParagraphCxSpMiddle
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Aptos",sans-serif;}
p.MsoListParagraphCxSpLast, li.MsoListParagraphCxSpLast, div.MsoListParagraphCxSpLast
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:.5in;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Aptos",sans-serif;}
p.MsoQuote, li.MsoQuote, div.MsoQuote
	{mso-style-link:"Quote Char";
	margin-top:8.0pt;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:0in;
	text-align:center;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Aptos",sans-serif;
	color:#404040;
	font-style:italic;}
p.MsoIntenseQuote, li.MsoIntenseQuote, div.MsoIntenseQuote
	{mso-style-link:"Intense Quote Char";
	margin-top:.25in;
	margin-right:.6in;
	margin-bottom:.25in;
	margin-left:.6in;
	text-align:center;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:12.0pt;
	font-family:"Aptos",sans-serif;
	color:#0F4761;
	font-style:italic;}
span.MsoIntenseEmphasis
	{color:#0F4761;
	font-style:italic;}
span.MsoIntenseReference
	{font-variant:small-caps;
	color:#0F4761;
	letter-spacing:.25pt;
	font-weight:bold;}
span.Heading1Char
	{mso-style-name:"Heading 1 Char";
	mso-style-link:"Heading 1";
	font-family:"Aptos Display",sans-serif;
	color:#0F4761;}
span.Heading2Char
	{mso-style-name:"Heading 2 Char";
	mso-style-link:"Heading 2";
	font-family:"Aptos Display",sans-serif;
	color:#0F4761;}
span.Heading3Char
	{mso-style-name:"Heading 3 Char";
	mso-style-link:"Heading 3";
	font-family:"Times New Roman",serif;
	color:#0F4761;}
span.Heading4Char
	{mso-style-name:"Heading 4 Char";
	mso-style-link:"Heading 4";
	font-family:"Times New Roman",serif;
	color:#0F4761;
	font-style:italic;}
span.Heading5Char
	{mso-style-name:"Heading 5 Char";
	mso-style-link:"Heading 5";
	font-family:"Times New Roman",serif;
	color:#0F4761;}
span.Heading6Char
	{mso-style-name:"Heading 6 Char";
	mso-style-link:"Heading 6";
	font-family:"Times New Roman",serif;
	color:#595959;
	font-style:italic;}
span.Heading7Char
	{mso-style-name:"Heading 7 Char";
	mso-style-link:"Heading 7";
	font-family:"Times New Roman",serif;
	color:#595959;}
span.Heading8Char
	{mso-style-name:"Heading 8 Char";
	mso-style-link:"Heading 8";
	font-family:"Times New Roman",serif;
	color:#272727;
	font-style:italic;}
span.Heading9Char
	{mso-style-name:"Heading 9 Char";
	mso-style-link:"Heading 9";
	font-family:"Times New Roman",serif;
	color:#272727;}
span.TitleChar
	{mso-style-name:"Title Char";
	mso-style-link:Title;
	font-family:"Aptos Display",sans-serif;
	letter-spacing:-.5pt;}
span.SubtitleChar
	{mso-style-name:"Subtitle Char";
	mso-style-link:Subtitle;
	font-family:"Times New Roman",serif;
	color:#595959;
	letter-spacing:.75pt;}
span.QuoteChar
	{mso-style-name:"Quote Char";
	mso-style-link:Quote;
	color:#404040;
	font-style:italic;}
span.IntenseQuoteChar
	{mso-style-name:"Intense Quote Char";
	mso-style-link:"Intense Quote";
	color:#0F4761;
	font-style:italic;}
p.msonormal0, li.msonormal0, div.msonormal0
	{mso-style-name:msonormal;
	margin-right:0in;
	margin-left:0in;
	font-size:12.0pt;
	font-family:"Times New Roman",serif;}
span.citation-435
	{mso-style-name:citation-435;}
span.citation-434
	{mso-style-name:citation-434;}
span.citation-433
	{mso-style-name:citation-433;}
span.citation-432
	{mso-style-name:citation-432;}
span.citation-431
	{mso-style-name:citation-431;}
span.citation-430
	{mso-style-name:citation-430;}
span.citation-429
	{mso-style-name:citation-429;}
span.citation-428
	{mso-style-name:citation-428;}
span.math-inline
	{mso-style-name:math-inline;}
span.citation-423
	{mso-style-name:citation-423;}
span.citation-422
	{mso-style-name:citation-422;}
span.citation-421
	{mso-style-name:citation-421;}
span.citation-420
	{mso-style-name:citation-420;}
span.citation-419
	{mso-style-name:citation-419;}
span.citation-418
	{mso-style-name:citation-418;}
span.citation-417
	{mso-style-name:citation-417;}
span.citation-416
	{mso-style-name:citation-416;}
span.citation-415
	{mso-style-name:citation-415;}
span.citation-414
	{mso-style-name:citation-414;}
span.citation-413
	{mso-style-name:citation-413;}
span.citation-412
	{mso-style-name:citation-412;}
span.citation-411
	{mso-style-name:citation-411;}
span.citation-410
	{mso-style-name:citation-410;}
span.citation-409
	{mso-style-name:citation-409;}
span.citation-406
	{mso-style-name:citation-406;}
span.citation-405
	{mso-style-name:citation-405;}
span.citation-404
	{mso-style-name:citation-404;}
span.citation-403
	{mso-style-name:citation-403;}
span.citation-402
	{mso-style-name:citation-402;}
span.citation-401
	{mso-style-name:citation-401;}
span.citation-400
	{mso-style-name:citation-400;}
span.citation-399
	{mso-style-name:citation-399;}
span.citation-398
	{mso-style-name:citation-398;}
span.citation-397
	{mso-style-name:citation-397;}
span.citation-396
	{mso-style-name:citation-396;}
span.citation-395
	{mso-style-name:citation-395;}
span.citation-394
	{mso-style-name:citation-394;}
span.citation-393
	{mso-style-name:citation-393;}
span.citation-392
	{mso-style-name:citation-392;}
span.citation-389
	{mso-style-name:citation-389;}
span.citation-388
	{mso-style-name:citation-388;}
span.citation-387
	{mso-style-name:citation-387;}
span.citation-386
	{mso-style-name:citation-386;}
span.citation-385
	{mso-style-name:citation-385;}
span.citation-384
	{mso-style-name:citation-384;}
span.citation-383
	{mso-style-name:citation-383;}
span.citation-382
	{mso-style-name:citation-382;}
span.citation-381
	{mso-style-name:citation-381;}
span.citation-380
	{mso-style-name:citation-380;}
span.citation-379
	{mso-style-name:citation-379;}
span.citation-376
	{mso-style-name:citation-376;}
span.citation-375
	{mso-style-name:citation-375;}
span.citation-374
	{mso-style-name:citation-374;}
span.citation-373
	{mso-style-name:citation-373;}
span.citation-372
	{mso-style-name:citation-372;}
span.citation-371
	{mso-style-name:citation-371;}
span.citation-370
	{mso-style-name:citation-370;}
span.citation-369
	{mso-style-name:citation-369;}
span.citation-368
	{mso-style-name:citation-368;}
span.citation-367
	{mso-style-name:citation-367;}
span.citation-366
	{mso-style-name:citation-366;}
span.citation-363
	{mso-style-name:citation-363;}
span.citation-362
	{mso-style-name:citation-362;}
span.citation-361
	{mso-style-name:citation-361;}
span.citation-360
	{mso-style-name:citation-360;}
span.citation-359
	{mso-style-name:citation-359;}
span.citation-358
	{mso-style-name:citation-358;}
span.citation-357
	{mso-style-name:citation-357;}
span.citation-356
	{mso-style-name:citation-356;}
span.citation-355
	{mso-style-name:citation-355;}
span.citation-354
	{mso-style-name:citation-354;}
span.citation-351
	{mso-style-name:citation-351;}
span.citation-350
	{mso-style-name:citation-350;}
span.citation-349
	{mso-style-name:citation-349;}
span.citation-348
	{mso-style-name:citation-348;}
span.citation-347
	{mso-style-name:citation-347;}
span.citation-346
	{mso-style-name:citation-346;}
span.citation-345
	{mso-style-name:citation-345;}
span.ng-tns-c2140515289-54
	{mso-style-name:ng-tns-c2140515289-54;}
span.mat-mdc-button-persistent-ripple
	{mso-style-name:mat-mdc-button-persistent-ripple;}
span.mat-focus-indicator
	{mso-style-name:mat-focus-indicator;}
span.mat-mdc-button-touch-target
	{mso-style-name:mat-mdc-button-touch-target;}
span.HTMLPreformattedChar
	{mso-style-name:"HTML Preformatted Char";
	mso-style-link:"HTML Preformatted";
	font-family:"Courier New";}
span.hljs-comment
	{mso-style-name:hljs-comment;}
span.hljs-keyword
	{mso-style-name:hljs-keyword;}
span.hljs-number
	{mso-style-name:hljs-number;}
span.citation-342
	{mso-style-name:citation-342;}
span.citation-341
	{mso-style-name:citation-341;}
span.citation-340
	{mso-style-name:citation-340;}
span.citation-339
	{mso-style-name:citation-339;}
span.citation-338
	{mso-style-name:citation-338;}
span.citation-337
	{mso-style-name:citation-337;}
span.citation-336
	{mso-style-name:citation-336;}
span.citation-333
	{mso-style-name:citation-333;}
span.citation-332
	{mso-style-name:citation-332;}
span.citation-331
	{mso-style-name:citation-331;}
span.citation-330
	{mso-style-name:citation-330;}
span.citation-329
	{mso-style-name:citation-329;}
span.citation-328
	{mso-style-name:citation-328;}
span.citation-327
	{mso-style-name:citation-327;}
span.citation-326
	{mso-style-name:citation-326;}
span.citation-325
	{mso-style-name:citation-325;}
span.citation-324
	{mso-style-name:citation-324;}
span.citation-323
	{mso-style-name:citation-323;}
span.citation-322
	{mso-style-name:citation-322;}
span.citation-321
	{mso-style-name:citation-321;}
span.citation-320
	{mso-style-name:citation-320;}
span.citation-319
	{mso-style-name:citation-319;}
span.citation-318
	{mso-style-name:citation-318;}
span.citation-315
	{mso-style-name:citation-315;}
span.citation-314
	{mso-style-name:citation-314;}
span.msoIns
	{mso-style-name:"";
	text-decoration:underline;
	color:teal;}
span.msoDel
	{mso-style-name:"";
	text-decoration:line-through;
	color:red;}
.MsoPapDefault
	{margin-bottom:8.0pt;
	line-height:115%;}
@page WordSection1
	{size:8.5in 11.0in;
	margin:1.0in 1.0in 1.0in 1.0in;}
div.WordSection1
	{page:WordSection1;}
 /* List Definitions */
 ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>

</head>

<body lang=EN-US style='word-wrap:break-word'>

<div class=WordSection1>

<p class=MsoNormal><b>Slide 1–2: Critical Section</b></p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#129504;</span>
Easy Explanation:</b></p>

<p class=MsoNormal>A <b>critical section</b> is a part of code where threads
share and modify common resources (like variables or files).<br>
If multiple threads enter at once, errors (called <b>race conditions</b>)
occur.<br>
We need to make sure that <b>only one thread runs this part at a time</b>.</p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#128161;</span>
Example:</b></p>

<p class=MsoNormal>Two threads increasing counter. If both do it together, the
final result may be wrong.</p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#129513;</span>
Use Case:</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Banking: Two ATMs updating same account balance.</li>
 <li class=MsoNormal>GPU threads updating shared array index.</li>
</ul>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#128216;</span>
Numerical Example:</b></p>

<p class=MsoNormal>If counter=0, and two threads both read 0 and add 1 &#8594;
both write 1.<br>
Expected result: 2<br>
Actual result: 1 (race condition)</p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#128221;</span>
MCQs:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>What is a critical section?<br>
     a) Code that runs faster<br>
     b) Code that accesses shared data (<span style='font-family:"Segoe UI Emoji",sans-serif'>&#9989;</span>)<br>
     c) Debugging section<br>
     d) GPU memory part</li>
 <li class=MsoNormal>What happens if two threads enter a critical section
     together?<br>
     a) Deadlock<br>
     b) Race condition (<span style='font-family:"Segoe UI Emoji",sans-serif'>&#9989;</span>)<br>
     c) No issue<br>
     d) Context switch</li>
</ol>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 3–4: Dekker’s Algorithm (Version 1)</b></p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#129504;</span>
Easy Explanation:</b></p>

<p class=MsoNormal>Dekker’s Algorithm is one of the first methods to allow <b>two
threads</b> to safely share a resource.<br>
It uses a variable (thread_no) to decide whose turn it is.</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Thread1 runs only if thread_no == 1</li>
 <li class=MsoNormal>After finishing, it sets thread_no = 2 to let Thread2 go.</li>
</ul>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#128161;</span>
Use Case:</b></p>

<p class=MsoNormal>Old operating systems used this kind of software locking
before hardware atomic operations existed.</p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#128216;</span>
Numerical Concept:</b></p>

<p class=MsoNormal>If each thread takes 1 second in critical section, total
time for 2 threads = 2 seconds (no overlap).</p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#128221;</span>
MCQs:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Dekker’s Algorithm controls access using:<br>
     a) A shared counter<br>
     b) A turn variable (<span style='font-family:"Segoe UI Emoji",sans-serif'>&#9989;</span>)<br>
     c) Flags<br>
     d) Locks</li>
 <li class=MsoNormal>How many threads does Version 1 support?<br>
     a) 1<br>
     b) 2 (<span style='font-family:"Segoe UI Emoji",sans-serif'>&#9989;</span>)<br>
     c) Unlimited<br>
     d) Depends on CPU</li>
</ol>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 5–6: Dekker’s Algorithm (Version 2)</b></p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#129504;</span>
Easy Explanation:</b></p>

<p class=MsoNormal>Uses <b>two boolean flags (th1, th2)</b>.<br>
Each thread checks if the other thread is inside the critical section.<br>
If true &#8594; it waits.</p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#128161;</span>
Use Case:</b></p>

<p class=MsoNormal>Two GPU blocks writing to a single shared array. Each must
check if the other is writing.</p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#9888;&#65039;</span>
Problem:</b></p>

<p class=MsoNormal>If both set their flag to true at the same time &#8594; both
wait forever &#8594; <b>deadlock</b>.</p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#128221;</span>
MCQs:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>What do th1 and th2 represent?<br>
     a) Thread IDs<br>
     b) Flags for critical section entry (<span style='font-family:"Segoe UI Emoji",sans-serif'>&#9989;</span>)<br>
     c) Turn variable<br>
     d) Priority levels</li>
 <li class=MsoNormal>What can Version 2 of Dekker’s Algorithm lead to?<br>
     a) Faster execution<br>
     b) Deadlock (<span style='font-family:"Segoe UI Emoji",sans-serif'>&#9989;</span>)<br>
     c) Starvation<br>
     d) No effect</li>
</ol>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 7–9: Dekker’s Algorithm (Version 3)</b></p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#129504;</span>
Easy Explanation:</b></p>

<p class=MsoNormal>Improved version that sets “want to enter” before checking
the other’s flag.<br>
Ensures only one can proceed at a time &#8594; better <b>mutual exclusion</b>.</p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#128161;</span>
Use Case:</b></p>

<p class=MsoNormal>Two CPU threads updating shared GPU buffer.</p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#129518;</span>
Numerical Concept:</b></p>

<p class=MsoNormal>If both try at same time, one must wait &#8594; serial
execution ensures correctness.</p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#128221;</span>
MCQs:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>What improvement does Version 3 make?<br>
     a) Adds a timer<br>
     b) Sets flag before checking other’s flag (<span style='font-family:"Segoe UI Emoji",sans-serif'>&#9989;</span>)<br>
     c) Removes waiting<br>
     d) Uses atomic operations</li>
 <li class=MsoNormal>What does “mutual exclusion” mean?<br>
     a) Both threads can run together<br>
     b) Only one thread in critical section at a time (<span style='font-family:
     "Segoe UI Emoji",sans-serif'>&#9989;</span>)<br>
     c) Threads run alternately<br>
     d) Threads never run</li>
</ol>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 10–12: Peterson’s Algorithm</b></p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#129504;</span>
Easy Explanation:</b></p>

<p class=MsoNormal>Peterson’s algorithm combines two ideas:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Each thread sets its flag[i] = true &#8594; “I want to
     enter.”</li>
 <li class=MsoNormal>A turn variable decides who goes first.</li>
</ol>

<p class=MsoNormal>If both want to enter &#8594; the one whose turn it is <b>waits</b>.</p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#128161;</span>
Use Case:</b></p>

<p class=MsoNormal>Used for two threads in CPU or GPU to share data safely.</p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#129518;</span>
Numerical Example:</b></p>

<p class=MsoNormal>If Thread1 sets flag[0]=true and Thread2 sets flag[1]=true
and turn=1 &#8594; Thread1 waits, Thread2 enters first.</p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#128221;</span>
MCQs:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>What does the turn variable do in Peterson’s Algorithm?<br>
     a) Acts as a flag<br>
     b) Breaks ties (<span style='font-family:"Segoe UI Emoji",sans-serif'>&#9989;</span>)<br>
     c) Stores process ID<br>
     d) Measures time</li>
 <li class=MsoNormal>What property does Peterson’s Algorithm ensure?<br>
     a) Random scheduling<br>
     b) Mutual exclusion and progress (<span style='font-family:"Segoe UI Emoji",sans-serif'>&#9989;</span>)<br>
     c) Deadlock<br>
     d) None</li>
</ol>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 13–15: __syncthreads() in CUDA</b></p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#129504;</span>
Easy Explanation:</b></p>

<p class=MsoNormal>A <b>barrier</b> in GPU.<br>
It ensures <b>all threads in a block</b> reach the same point before moving on.<br>
Used to synchronize shared memory access.</p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#128161;</span>
Use Case:</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>GPU kernel doing sum reduction or matrix multiplication.</li>
 <li class=MsoNormal>After writing to shared memory, use __syncthreads() before
     reading it again.</li>
</ul>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#128216;</span>
Numerical Example:</b></p>

<p class=MsoNormal>Block of 8 threads &#8594; if 7 reach the barrier, the 8th
must also reach before all can continue.</p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#128221;</span>
MCQs:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>What does __syncthreads() do?<br>
     a) Stops all GPU blocks<br>
     b) Synchronizes all threads in a block (<span style='font-family:"Segoe UI Emoji",sans-serif'>&#9989;</span>)<br>
     c) Synchronizes across GPU<br>
     d) Clears memory</li>
 <li class=MsoNormal>When is __syncthreads() required?<br>
     a) Before shared memory access (<span style='font-family:"Segoe UI Emoji",sans-serif'>&#9989;</span>)<br>
     b) During global memory write<br>
     c) During kernel launch<br>
     d) None</li>
</ol>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 16–17: atomicCAS() (Atomic Compare and Swap)</b></p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#129504;</span>
Easy Explanation:</b></p>

<p class=MsoNormal>A GPU <b>atomic operation</b> used to build locks.<br>
Many threads try to set a variable (lock=1).<br>
Only one succeeds; others keep trying until the lock is released.</p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#128161;</span>
Use Case:</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Updating a global counter</li>
 <li class=MsoNormal>Implementing GPU locks</li>
 <li class=MsoNormal>Ensuring one thread writes at a time</li>
</ul>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#129518;</span>
Numerical Example:</b></p>

<p class=MsoNormal>If 4 threads try to update lock=0:<br>
&#8594; One sets it to 1, others wait.<br>
&#8594; When done, it sets lock=0, next one enters.</p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#128221;</span>
MCQs:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>What does atomicCAS() do?<br>
     a) Adds two numbers<br>
     b) Atomically compares and swaps values (<span style='font-family:"Segoe UI Emoji",sans-serif'>&#9989;</span>)<br>
     c) Synchronizes across blocks<br>
     d) Deletes data</li>
 <li class=MsoNormal>What happens if all threads call atomicCAS(lock,0,1)?<br>
     a) All enter together<br>
     b) Only one succeeds, others wait (<span style='font-family:"Segoe UI Emoji",sans-serif'>&#9989;</span>)<br>
     c) GPU crash<br>
     d) Deadlock</li>
</ol>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 18: Comparison</b></p>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#129504;</span>
Easy Explanation:</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Use __syncthreads() &#8594; for thread sync <b>inside</b>
     a block.</li>
 <li class=MsoNormal>Use atomicCAS() &#8594; for <b>global synchronization</b>
     across blocks.</li>
</ul>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#128161;</span>
Use Case:</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>__syncthreads(): Shared memory operations</li>
 <li class=MsoNormal>atomicCAS(): Global counters, locks</li>
</ul>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#129518;</span>
Numerical Exercise:</b></p>

<p class=MsoNormal>If 3 blocks each add 10 numbers:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>__syncthreads() handles per-block sync</li>
 <li class=MsoNormal>atomicCAS() used for final global sum update</li>
</ul>

<p class=MsoNormal><b><span style='font-family:"Segoe UI Emoji",sans-serif'>&#128221;</span>
MCQs:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>When to use __syncthreads()?<br>
     a) Across all blocks<br>
     b) Inside a block (<span style='font-family:"Segoe UI Emoji",sans-serif'>&#9989;</span>)<br>
     c) For CPU threads<br>
     d) For file IO</li>
 <li class=MsoNormal>When to use atomicCAS()?<br>
     a) Inside one thread<br>
     b) For shared global variable updates (<span style='font-family:"Segoe UI Emoji",sans-serif'>&#9989;</span>)<br>
     c) For printing logs<br>
     d) Never</li>
</ol>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<div style='border:none;border-bottom:double windowtext 2.25pt;padding:0in 0in 1.0pt 0in'>

<p class=MsoNormal style='border:none;padding:0in'>&nbsp;</p>

</div>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal><b>Slide 2: Critical Section</b></p>

<p class=MsoNormal><b>Explanation:</b><br>
Imagine a shared notebook that multiple people (threads) are trying to write in
at the same time. A &quot;critical section&quot; is like a rule that says,
&quot;Only one person can write in the notebook at a time.&quot; This prevents
everyone from scribbling over each other's work and creating a mess (a
&quot;race condition&quot;). For this rule to work properly, it must guarantee
three things:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>Mutual Exclusion:</b>&nbsp;Only one thread can be in
     the critical section at a time.</li>
 <li class=MsoNormal><b>Progress:</b>&nbsp;If no thread is in the critical
     section, a thread that wants to enter should be able to do so.</li>
 <li class=MsoNormal><b>Bounded Waiting:</b>&nbsp;A thread shouldn't have to
     wait forever to get its turn; no &quot;starvation.&quot;</li>
</ol>

<p class=MsoNormal><b>MCQ:</b><br>
What is the primary problem that occurs if multiple threads enter a critical
section simultaneously?<br>
a) Deadlock<br>
b) Memory Leak<br>
c) Race Condition<br>
d) Buffer Overflow<br>
<b>Answer:</b>&nbsp;c) Race Condition</p>

<p class=MsoNormal><b>Use Case:</b><br>
A shared bank account balance. If two ATM withdrawals happen at the same time
without coordination, both might read the old balance, leading to an incorrect
final amount.</p>

<p class=MsoNormal><b>Numerical:</b><br>
Two threads each increment a shared variable&nbsp;count&nbsp;(initial value 10)
1000 times. What is the maximum possible final value of&nbsp;count? What is the
minimum possible value if a race condition occurs?<br>
<b>Answer:</b>&nbsp;Maximum: 2010 (if no race condition). Minimum: 1010 (if
both often read the same value and overwrite each other).</p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=1 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slides 3-6: Dekker’s Algorithm - Version 1</b></p>

<p class=MsoNormal><b>Explanation:</b><br>
This is like two kids sharing a single toy. They have a token (thread_no) that
says whose turn it is. If the token is &quot;1&quot;, only Kid1 can play with
the toy (enter the critical section). When Kid1 is done, they pass the token to
Kid2 (thread_no = 2). Now, only Kid2 can play. This ensures only one kid plays
at a time. It's simple but only works for two threads.</p>

<p class=MsoNormal><b>MCQ:</b><br>
In Dekker's Algorithm Version 1, what does the variable&nbsp;thread_no&nbsp;represent?<br>
a) The total number of threads<br>
b) The ID of the thread currently in the critical section<br>
c) The ID of the thread allowed to enter the critical section next<br>
d) A random number<br>
<b>Answer:</b>&nbsp;c) The ID of the thread allowed to enter the critical
section next</p>

<p class=MsoNormal><b>Use Case:</b><br>
Controlling access to a single printer between two computers.</p>

<p class=MsoNormal><b>Numerical:</b><br>
If&nbsp;thread_no&nbsp;is initially 1, and Thread1 runs its critical section 5
times, how many times will Thread2 have run its critical section by the time
Thread1 finishes its 5th turn?<br>
<b>Answer:</b>&nbsp;4 times. (After Thread1's 1st turn,&nbsp;thread_no=2&nbsp;(T2
runs). After T2,&nbsp;thread_no=1&nbsp;(T1 runs again), and so on.)</p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=1 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slides 7-8: Dekker’s Algorithm - Version 2</b></p>

<p class=MsoNormal><b>Explanation:</b><br>
Now, each kid raises a flag (th1&nbsp;or&nbsp;th2) to say, &quot;I want to
play.&quot; Before playing, a kid checks if the other's flag is raised. If it
is, they wait. The problem? If both raise their flags at the exact same
instant, they will both see the other's flag is up and wait forever for each other
to lower it—a&nbsp;<b>deadlock</b>. They are stuck forever.</p>

<p class=MsoNormal><b>MCQ:</b><br>
What is the main flaw of Dekker's Algorithm Version 2?<br>
a) It causes a race condition<br>
b) It only works for one thread<br>
c) It can lead to a deadlock<br>
d) It is too slow<br>
<b>Answer:</b>&nbsp;c) It can lead to a deadlock</p>

<p class=MsoNormal><b>Use Case:</b><br>
(This version is flawed and not used in practice, but it's a step in
understanding the evolution of solutions).</p>

<p class=MsoNormal><b>Numerical:</b><br>
If Thread1 sets&nbsp;th1 = true&nbsp;and, at the same moment, Thread2
sets&nbsp;th2 = true, what will happen to both threads?<br>
<b>Answer:</b>&nbsp;Both threads will be stuck in their&nbsp;while&nbsp;loops
forever, causing a deadlock.</p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=1 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slides 9-10: Dekker’s Algorithm - Version 3</b></p>

<p class=MsoNormal><b>Explanation:</b><br>
This version tries to fix the deadlock. A kid now raises their flag&nbsp;<i>before</i>&nbsp;checking
the other's flag. This is like saying &quot;I definitely want to play&quot;
first. However, if both kids do this simultaneously, they will both have their
flags raised and will both be stuck waiting for the other to lower theirs. This
is the same&nbsp;<b>deadlock</b>&nbsp;problem as Version 2.</p>

<p class=MsoNormal><b>MCQ:</b><br>
In Version 3, when does a thread set its&nbsp;wantstoenter&nbsp;flag to true?<br>
a) After it checks the other thread's flag<br>
b) At the same time as it checks the other thread's flag<br>
c) Before it checks the other thread's flag<br>
d) After it exits the critical section<br>
<b>Answer:</b>&nbsp;c) Before it checks the other thread's flag</p>

<p class=MsoNormal><b>Use Case:</b><br>
(Like Version 2, this is a conceptual step towards a correct solution, not used
in practice).</p>

<p class=MsoNormal><b>Numerical:</b><br>
Create a step-by-step scenario where Thread1 and Thread2 cause a deadlock in
Version 3.<br>
<b>Answer:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Thread1 sets&nbsp;th1wantstoenter = true.</li>
 <li class=MsoNormal><i>At the same time</i>, Thread2 sets&nbsp;th2wantstoenter
     = true.</li>
 <li class=MsoNormal>Thread1 checks&nbsp;th2wantstoenter, finds it true, and
     waits.</li>
 <li class=MsoNormal>Thread2 checks&nbsp;th1wantstoenter, finds it true, and
     waits.</li>
 <li class=MsoNormal>Both wait forever &#8594; Deadlock.</li>
</ol>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=1 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slides 11-12: Peterson's Algorithm</b></p>

<p class=MsoNormal><b>Explanation:</b><br>
This is the clever solution that works for two threads. It uses two ideas:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>Flags:</b>&nbsp;&quot;I want to enter.&quot;</li>
 <li class=MsoNormal><b>A Turn Variable:</b>&nbsp;A tie-breaker.<br>
     A thread says &quot;I want in&quot; and then politely says, &quot;It's
     your turn.&quot; It then waits if both conditions are true: the other
     thread wants in AND it's actually the other thread's turn. This ensures
     that if both want to enter, one will always back off based on the turn,
     preventing deadlock and ensuring fairness.</li>
</ol>

<p class=MsoNormal><b>MCQ:</b><br>
In Peterson's Algorithm, what is the purpose of the&nbsp;turn&nbsp;variable?<br>
a) To count how many threads are waiting<br>
b) To act as a tie-breaker to prevent deadlock<br>
c) To indicate which thread has priority<br>
d) To store the result of the critical section<br>
<b>Answer:</b>&nbsp;b) To act as a tie-breaker to prevent deadlock</p>

<p class=MsoNormal><b>Use Case:</b><br>
Implementing a mutex (lock) for two threads in software where hardware support
isn't available.</p>

<p class=MsoNormal><b>Numerical:</b><br>
Thread0 and Thread1 both call Peterson's algorithm.&nbsp;flag[0] = true,&nbsp;turn&nbsp;is
set to 1 by Thread0.&nbsp;flag[1] = true,&nbsp;turn&nbsp;is set to 0 by
Thread1. Which thread will enter its critical section first and why?<br>
<b>Answer:</b>&nbsp;Thread1 will enter first. Thread0's wait condition is&nbsp;while
(flag[1] &amp;&amp; turn == 1). Since&nbsp;turn&nbsp;is 0 (not 1), Thread0's
condition is false, so it can proceed. Thread1's condition is&nbsp;while
(flag[0] &amp;&amp; turn == 0). Both&nbsp;flag[0]&nbsp;is true and&nbsp;turn ==
0&nbsp;is true, so Thread1 must wait.</p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=1 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slides 13 &amp; 15: __syncthreads() (Barrier)</b></p>

<p class=MsoNormal><b>Explanation:</b><br>
__syncthreads()&nbsp;is like a &quot;Start&quot; line in a relay race. All
runners (threads in a block) must get to the line before anyone is allowed to
start running the next part of the race. It makes sure that all threads have
finished their current work (e.g., writing to shared memory) before any thread
moves on to work that depends on that data.</p>

<p class=MsoNormal><b>MCQ:</b><br>
What is the scope of&nbsp;__syncthreads()&nbsp;in CUDA?<br>
a) All threads on the GPU<br>
b) All threads in a single block<br>
c) All threads with the same thread ID<br>
d) A single thread<br>
<b>Answer:</b>&nbsp;b) All threads in a single block</p>

<p class=MsoNormal><b>Use Case:</b><br>
<b>Parallel Reduction:</b>&nbsp;Adding up a large list of numbers. Each thread
loads a number into shared memory. A&nbsp;__syncthreads()&nbsp;ensures all
numbers are loaded before the addition process begins. Without it, some threads
might try to add numbers before others have loaded them.</p>

<p class=MsoNormal><b>Numerical:</b><br>
A CUDA block has 128 threads. They are performing a reduction. After the first
step, 64 threads are active. Is a&nbsp;__syncthreads()&nbsp;needed after this
step? Why?<br>
<b>Answer:</b>&nbsp;Yes. The 64 active threads will write their partial sums to
shared memory. The other 64 threads are now inactive, but the active ones must
be synchronized to ensure all 64 new values are written before the next step of
the reduction begins.</p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=1 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slides 14 &amp; 16: atomicCAS (Compare-and-Swap)</b></p>

<p class=MsoNormal><b>Explanation:</b><br>
atomicCAS&nbsp;is like a single-key bathroom. The lock on the door is either 0
(unlocked) or 1 (locked). A person (thread) tries to use the bathroom. They
check the lock: if it's 0, they atomically (in one, uninterruptible step) flip
it to 1 and go in. If it's already 1, they just wait, checking repeatedly. When
done, they set the lock back to 0. This ensures only one person is in the
bathroom at a time, even in a very crowded building (across the entire GPU).</p>

<p class=MsoNormal><b>MCQ:</b><br>
What does&nbsp;atomicCAS(lock, 0, 1)&nbsp;do?<br>
a) Sets the lock to 0 regardless of its previous value<br>
b) Sets the lock to 1 only if it was already 1<br>
c) Sets the lock to 1 only if it was 0, and returns the old value<br>
d) Adds 1 to the lock value<br>
<b>Answer:</b>&nbsp;c) Sets the lock to 1 only if it was 0, and returns the old
value</p>

<p class=MsoNormal><b>Use Case:</b><br>
<b>Global Counter:</b>&nbsp;Thousands of threads across many blocks counting
how many pixels in an image are a certain color. Each thread uses&nbsp;atomicAdd&nbsp;(which
uses principles like&nbsp;atomicCAS) to safely increment the global counter
without corrupting the final result.</p>

<p class=MsoNormal><b>Numerical:</b><br>
A global variable&nbsp;lock&nbsp;is 0. Four threads call&nbsp;atomicCAS(&amp;lock,
0, 1)&nbsp;at the same time. What are the possible return values for each
thread, and what does the&nbsp;lock&nbsp;variable become?<br>
<b>Answer:</b>&nbsp;One thread will get a return value of 0 (and will win the
lock). The other three threads will get a return value of 1 (because the first
thread already changed it). The&nbsp;lock&nbsp;variable becomes 1.</p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=1 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slides 17-18: Comparisons</b></p>

<p class=MsoNormal><b>Explanation:</b><br>
This slide compares the two main tools we've learned.</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>__syncthreads()&nbsp;is a&nbsp;<b>team huddle</b>. The
     whole team (block) must gather and sync up before moving on. It's about
     coordination and shared preparation.</li>
 <li class=MsoNormal>atomicCAS()&nbsp;is a&nbsp;<b>take-a-number system</b>.
     Everyone (across the GPU) needs the same resource, but they must go one at
     a time. It's about exclusive access and serialization.</li>
</ul>

<p class=MsoNormal><b>MCQ:</b><br>
You are implementing a tiled matrix multiplication where threads in a block
load tiles of data into shared memory. Which synchronization primitive should
you use before beginning the computation on these tiles?<br>
a)&nbsp;atomicCAS<br>
b)&nbsp;__syncthreads<br>
c) Neither<br>
d) Both<br>
<b>Answer:</b>&nbsp;b)&nbsp;__syncthreads</p>

<p class=MsoNormal><b>Use Case:</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>__syncthreads<b>:</b>&nbsp;Tiled matrix multiplication,
     parallel reduction (within a block).</li>
 <li class=MsoNormal>atomicCAS<b>:</b>&nbsp;Implementing a lock, building a
     linked list accessible by all blocks, incrementing a device-wide counter.</li>
</ul>

<p class=MsoNormal><b>Numerical:</b><br>
You have a kernel with 10 blocks of 256 threads each. Each thread needs to
update a single global variable&nbsp;counter. Is&nbsp;__syncthreads()&nbsp;sufficient
to ensure the final value of&nbsp;counter&nbsp;is correct? If not, what should
you use?<br>
<b>Answer:</b>&nbsp;No,&nbsp;__syncthreads()&nbsp;only synchronizes within a
block. It does nothing for threads in other blocks. To safely update a global
variable from all threads, you must use an atomic operation like&nbsp;atomicAdd().</p>

<p class=MsoNormal>&nbsp;</p>

<div style='border:none;border-bottom:double windowtext 2.25pt;padding:0in 0in 1.0pt 0in'>

<p class=MsoNormal style='border:none;padding:0in'>&nbsp;</p>

</div>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>The following is a slide-by-slide explanation of the
provided GPU programming lecture, along with multiple-choice questions (MCQs),
use cases, and, where applicable, numerical examples.</p>

<p class=MsoNormal><b>Slide 2: Critical Section</b></p>

<p class=MsoNormal><b>Explanation</b></p>

<p class=MsoNormal>A <b>critical section</b> is a part of code where <b>shared
resources</b> (like global variables or memory) are accessed or changed<sup>11</sup>.
It's crucial that <b>only one thread</b> executes this section at any given
time<sup>2</sup>. If multiple threads try to run this code simultaneously, it
causes <b>race conditions</b>, which lead to wrong or unpredictable program
results<sup>3</sup>.</p>

<p class=MsoNormal>To correctly solve the critical section problem, three
conditions must be met:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>Mutual Exclusion</b>: Only one thread can be in the
     critical section at a time<sup>4</sup>.</li>
 <li class=MsoNormal><b>Progress</b>: If no thread is in the critical section
     and some threads want to enter, only those threads that are not in their
     remainder section can decide which thread will enter next, and this
     decision cannot be postponed indefinitely<sup>5</sup>.</li>
 <li class=MsoNormal><b>Bounded Waiting</b>: There's a limit to how many times
     other threads can enter the critical section after a thread has requested
     to enter but before its request is granted<sup>6</sup>.</li>
</ol>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Use Cases</b></p>

<table class=MsoNormalTable border=0 cellspacing=3 cellpadding=0>
 <thead>
  <tr>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Concept</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Use Case</b></p>
   </td>
  </tr>
 </thead>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Critical Section</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Code that updates a <b>global counter</b> variable<sup>77</sup>.</p>
  </td>
 </tr>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Race Condition</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Two threads trying to write data to the <b>same line in a
  shared log file</b> simultaneously<sup>888</sup>.</p>
  </td>
 </tr>
</table>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Which of the following is NOT a required condition for a
     correct solution to the critical section problem?</li>
</ol>

<p class=MsoNormal>A) Mutual Exclusion 9</p>

<p class=MsoNormal>B) Deadlock Avoidance</p>

<p class=MsoNormal>C) Progress 10D) Bounded Waiting 11</p>

<p class=MsoNormal><b>Answer: B) Deadlock Avoidance</b></p>

<ol style='margin-top:0in' start=2 type=1>
 <li class=MsoNormal>What is the potential issue if multiple threads enter a
     critical section simultaneously?</li>
</ol>

<p class=MsoNormal>A) Mutual Exclusion</p>

<p class=MsoNormal>B) Thread Starvation</p>

<p class=MsoNormal>C) Race Conditions 12</p>

<p class=MsoNormal>D) Bounded Waiting</p>

<p class=MsoNormal><b>Answer: C) Race Conditions</b></p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Numerical Example (Illustrative)</b></p>

<p class=MsoNormal>Consider a global variable $\text{count} = 0$. Two threads
execute the critical section $\text{count} = \text{count} + 1$ simultaneously.</p>

<table class=MsoNormalTable border=0 cellspacing=3 cellpadding=0>
 <thead>
  <tr>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Thread 1 (T1)</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Thread 2 (T2)</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>count (Shared Variable)</b></p>
   </td>
  </tr>
 </thead>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Reads $\text{count}$ (0) <sup>13</sup></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Reads $\text{count}$ (0) <sup>14</sup></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>0</p>
  </td>
 </tr>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Calculates $0 + 1 = 1$ <sup>15</sup></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Calculates $0 + 1 = 1$ <sup>16</sup></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>0</p>
  </td>
 </tr>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Writes $1$ to $\text{count}$ <sup>17</sup></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Writes $1$ to $\text{count}$ <sup>18</sup></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>1</p>
  </td>
 </tr>
</table>

<p class=MsoNormal>The final result is $\text{count} = 1$, when the expected
result from two increments is 2<sup>19</sup>. This is an example of a <b>race
condition</b><sup>20</sup>.</p>

<p class=MsoNormal><b>Slide 3: Data Race Example</b></p>

<p class=MsoNormal><b>Explanation</b></p>

<p class=MsoNormal>This slide illustrates a race condition using a shared
integer variable counter initialized to 0<sup>21</sup>. If two threads run the increment()
function simultaneously:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Both threads read the value of counter (which is 0)<sup>2222</sup>.</li>
 <li class=MsoNormal>Both threads independently add 1, resulting in 1 for each<sup>23</sup>.</li>
 <li class=MsoNormal>Both threads write the value 1 back to counter<sup>24</sup>.</li>
</ol>

<p class=MsoNormal>The correct final value should be 2 (from two increments),
but the actual final result is 1<sup>25</sup>. This error occurs because both
threads modified the shared variable without proper coordination, which is a <b>race
condition</b><sup>26</sup>. The line counter = counter + 1; is the <b>critical
section</b> (CS)<sup>27</sup>.</p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Use Cases</b></p>

<table class=MsoNormalTable border=0 cellspacing=3 cellpadding=0>
 <thead>
  <tr>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Concept</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Use Case</b></p>
   </td>
  </tr>
 </thead>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Data Race</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Concurrent modifications to a <b>shared linked list</b> where
  one thread updates a pointer while another thread is reading from it.</p>
  </td>
 </tr>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Critical Section</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>The <b>update operation</b> on a shared data structure
  like an array, a stack, or a queue.</p>
  </td>
 </tr>
</table>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>In the provided example, why does the final result of
     counter equal 1 instead of the expected 2?</li>
</ol>

<p class=MsoNormal>A) One thread was blocked by a mutex.</p>

<p class=MsoNormal>B) The addition operation failed.</p>

<p class=MsoNormal>C) Both threads read the stale value of 0 before either
wrote back the updated value. 2828282828</p>

<p class=MsoNormal>D) The critical section was never entered.</p>

<p class=MsoNormal><b>Answer: C) Both threads read the stale value of 0 before
either wrote back the updated value.</b></p>

<ol style='margin-top:0in' start=2 type=1>
 <li class=MsoNormal>What is the line counter = counter + 1; identified as in
     this context?</li>
</ol>

<p class=MsoNormal>A) Remainder section</p>

<p class=MsoNormal>B) Entry section</p>

<p class=MsoNormal>C) Exit section</p>

<p class=MsoNormal>D) Critical section (CS) 29</p>

<p class=MsoNormal><b>Answer: D) Critical section (CS)</b></p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Numerical Example (Illustrative)</b></p>

<p class=MsoNormal>The slide itself is a numerical/timing example:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Initial: $\text{counter} = 0$ <sup>30</sup></li>
 <li class=MsoNormal>T1 reads $\text{counter} \implies 0$ <sup>31</sup></li>
 <li class=MsoNormal>T2 reads $\text{counter} \implies 0$ <sup>32</sup></li>
 <li class=MsoNormal>T1 calculates $0+1 \implies 1$ <sup>33</sup></li>
 <li class=MsoNormal>T2 calculates $0+1 \implies 1$ <sup>34</sup></li>
 <li class=MsoNormal>T1 writes $\text{counter} \implies 1$ <sup>35</sup></li>
 <li class=MsoNormal>T2 writes $\text{counter} \implies 1$ <sup>36</sup></li>
 <li class=MsoNormal>Final result: 1 <sup>37</sup></li>
</ul>

<p class=MsoNormal><b>Slide 4-6: Dekker's Algorithm - Version 1</b></p>

<p class=MsoNormal><b>Explanation</b></p>

<p class=MsoNormal><b>Dekker's Algorithm</b> is one of the earliest software
solutions to ensure <b>mutual exclusion</b> for two processes (Thread1 and
Thread2)<sup>38</sup>.</p>

<p class=MsoNormal><b>Version 1</b> uses a single shared variable, thread_no,
initialized to 1, to determine whose turn it is to enter the Critical Section
(CS)<sup>39</sup>.</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Thread1</b> can enter the CS <i>only if</i> thread_no
     is 1. If thread_no is 2, Thread1 waits (while (thread_no == 2))<sup>40404040</sup>.</li>
 <li class=MsoNormal>After Thread1 finishes its CS, it sets thread_no = 2,
     giving permission to Thread2<sup>41414141</sup>.</li>
 <li class=MsoNormal><b>Thread2</b> can enter the CS <i>only if</i> thread_no
     is 2. If thread_no is 1, Thread2 waits (while (thread_no == 1))<sup>42424242</sup>.</li>
 <li class=MsoNormal>After Thread2 finishes its CS, it sets thread_no = 1,
     giving permission back to Thread1<sup>43434343</sup>.</li>
</ul>

<p class=MsoNormal>This version enforces strict <b>alternation</b>, meaning
Thread1 and Thread2 must take turns, even if one is ready to go again and the
other isn't<sup>44</sup>.</p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Use Cases</b></p>

<table class=MsoNormalTable border=0 cellspacing=3 cellpadding=0>
 <thead>
  <tr>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Concept</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Use Case</b></p>
   </td>
  </tr>
 </thead>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Dekker's Algorithm</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>An academic example to illustrate the fundamental
  challenges and software solutions for <b>mutual exclusion</b> in concurrent
  programming.</p>
  </td>
 </tr>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Strict Alternation</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>A simple two-device communication protocol where messages
  must alternate between the two parties.</p>
  </td>
 </tr>
</table>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>What is the main purpose of Dekker's Algorithm?</li>
</ol>

<p class=MsoNormal>A) To eliminate deadlock</p>

<p class=MsoNormal>B) To ensure fair resource allocation in a multi-core system</p>

<p class=MsoNormal>C) To ensure mutual exclusion for two processes 45</p>

<p class=MsoNormal>D) To prioritize one thread over another</p>

<p class=MsoNormal><b>Answer: C) To ensure mutual exclusion for two processes</b></p>

<ol style='margin-top:0in' start=2 type=1>
 <li class=MsoNormal>In Dekker's Algorithm - Version 1, if thread_no is 2,
     which thread will enter its critical section?</li>
</ol>

<p class=MsoNormal>A) Thread1, after a brief wait</p>

<p class=MsoNormal>B) Neither thread</p>

<p class=MsoNormal>C) Thread2, immediately 46</p>

<p class=MsoNormal>D) Thread1, as it is prioritized</p>

<p class=MsoNormal><b>Answer: C) Thread2, immediately</b></p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Numerical Example (Tracing)</b></p>

<p class=MsoNormal>Tracing the execution flow when $\text{thread\_no} = 1$:</p>

<table class=MsoNormalTable border=0 cellspacing=3 cellpadding=0>
 <thead>
  <tr>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Step</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Thread1</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Thread2</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>thread_no</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Who's in CS</b></p>
   </td>
  </tr>
 </thead>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>1</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>ready</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>ready</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>1</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Thread1 enters <sup>47</sup></p>
  </td>
 </tr>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>2</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>executes CS</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>waiting</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>1</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Thread1 <sup>48</sup></p>
  </td>
 </tr>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>3</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>exits CS $\to$ sets $\text{thread\_no}=2$</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>waiting</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>2</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>none <sup>49</sup></p>
  </td>
 </tr>
</table>

<p class=MsoNormal><b>Slide 7-8: Dekker's Algorithm - Version 2</b></p>

<p class=MsoNormal><b>Explanation</b></p>

<p class=MsoNormal><b>Version 2</b> of Dekker's Algorithm uses two separate
boolean <b>flags</b> (th1 and th2) to indicate a thread's status (in or wanting
to enter the CS)<sup>50505050</sup>.</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Entry Section for Thread1</b>:</li>
 <ol style='margin-top:0in' start=1 type=1>
  <li class=MsoNormal>It checks the other thread's flag: while (th2 == true)<sup>51</sup>.
      It waits if Thread2 is in or wants to enter the CS<sup>52</sup>.</li>
  <li class=MsoNormal>It sets its own flag: th1 = true<sup>53</sup>.</li>
 </ol>
 <li class=MsoNormal><b>Exit Section for Thread1</b>: It sets its flag to
     false: th1 = false<sup>54</sup>.</li>
</ul>

<p class=MsoNormal>This version ensures <b>mutual exclusion</b> because each
thread checks the other's flag before proceeding<sup>55555555</sup>. For
example, Thread1 must see th2 == false to proceed<sup>56565656</sup>.</p>

<p class=MsoNormal><b>Potential Issue</b>: If both threads execute the first
line of their entry section (the while loop check) at the same time, and both
see the other's flag as false, they both proceed to set their own flag to true
almost simultaneously. Then, both threads will be waiting for the other's flag
to turn false, leading to a <b>deadlock</b><sup>575757</sup>.</p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Use Cases</b></p>

<table class=MsoNormalTable border=0 cellspacing=3 cellpadding=0>
 <thead>
  <tr>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Concept</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Use Case</b></p>
   </td>
  </tr>
 </thead>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Deadlock Risk</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>This version illustrates the hazard of using only <b>&quot;check-then-set&quot;</b>
  logic for mutual exclusion, especially when both threads can proceed past the
  initial check.</p>
  </td>
 </tr>
</table>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>What is the potential problem with Dekker's Algorithm -
     Version 2?</li>
</ol>

<p class=MsoNormal>A) Starvation</p>

<p class=MsoNormal>B) Violation of Mutual Exclusion</p>

<p class=MsoNormal>C) Deadlock 585858</p>

<p class=MsoNormal>D) Unbounded Waiting</p>

<p class=MsoNormal><b>Answer: C) Deadlock</b></p>

<ol style='margin-top:0in' start=2 type=1>
 <li class=MsoNormal>To enter its critical section, Thread1 in Version 2 must
     see which condition regarding Thread2's flag (th2)?</li>
</ol>

<p class=MsoNormal>A) $\text{th2} == \text{true}$</p>

<p class=MsoNormal>B) $\text{th2} == \text{false}$ 59595959</p>

<p class=MsoNormal>C) $\text{th2}$ is set to 1</p>

<p class=MsoNormal>D) $\text{th2}$ is volatile</p>

<p class=MsoNormal><b>Answer: B) $\text{th2} == \text{false}$</b></p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Numerical Example (State Analysis)</b></p>

<p class=MsoNormal>Analyzing the state where a deadlock occurs<sup>60</sup>:</p>

<table class=MsoNormalTable border=0 cellspacing=3 cellpadding=0>
 <thead>
  <tr>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Step</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Thread1 Flag (th1)</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Thread2 Flag (th2)</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Who Proceeds</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Why</b></p>
   </td>
  </tr>
 </thead>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Initial</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>F</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>F</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Either</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Both free</p>
  </td>
 </tr>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Simultaneous Request</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>T (T1 sets)</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>T (T2 sets)</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>None</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Deadlock possible <sup>61</sup></p>
  </td>
 </tr>
</table>

<p class=MsoNormal>If both set their flags to true before checking the other's,
then:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>T1 waits at while (th2 == true) <sup>62</sup></li>
 <li class=MsoNormal>T2 waits at while (th1 == true) <sup>63</sup></li>
 <li class=MsoNormal><b>Deadlock</b> occurs.</li>
</ul>

<p class=MsoNormal><b>Slide 9-10: Dekker's Algorithm - Version 3</b></p>

<p class=MsoNormal><b>Explanation</b></p>

<p class=MsoNormal><b>Version 3</b> is a slight modification of Version 2
designed to try and prevent the deadlock by changing the order of operations in
the entry section<sup>64</sup>.</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>The flags are renamed to th1wantstoenter and th2wantstoenter<sup>65</sup>.</li>
 <li class=MsoNormal><b>Crucially</b>, a thread sets its own flag to true <b>before</b>
     checking the other thread's flag<sup>66666666666666666666666666</sup>.</li>
 <li class=MsoNormal><b>Entry Section for Thread1</b>:</li>
 <ol style='margin-top:0in' start=1 type=1>
  <li class=MsoNormal>Sets intention: th1wantstoenter = true<sup>67</sup>.</li>
  <li class=MsoNormal>Checks other thread: while (th2wantstoenter == true)<sup>68</sup>.</li>
 </ol>
</ul>

<p class=MsoNormal>This ensures <b>mutual exclusion</b><sup>69</sup>. However,
the core problem from Version 2 remains: if both threads try to enter
simultaneously, they both set their flags to true, and then both check the
other's true flag and enter an endless wait (while(true)), leading once again
to a <b>deadlock</b><sup>70</sup>.</p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Use Cases</b></p>

<table class=MsoNormalTable border=0 cellspacing=3 cellpadding=0>
 <thead>
  <tr>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Concept</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Use Case</b></p>
   </td>
  </tr>
 </thead>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>&quot;Set-then-Check&quot; Logic</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>This version demonstrates that simply changing the order
  of setting the intention flag and checking the opponent's flag doesn't
  inherently solve the deadlock issue when both threads are highly competitive.</p>
  </td>
 </tr>
</table>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>What is the primary difference in the entry section of
     Version 3 compared to Version 2?</li>
</ol>

<p class=MsoNormal>A) The thread checks the other thread's flag after setting
its own intention flag to true. 71</p>

<p class=MsoNormal>B) The thread checks the other thread's flag before setting
its own intention flag to true.</p>

<p class=MsoNormal>C) Version 3 uses a turn variable instead of flags.</p>

<p class=MsoNormal>D) Version 3 only works with three or more threads.</p>

<p class=MsoNormal><b>Answer: A) The thread checks the other thread's flag <i>after</i>
setting its own intention flag to true.</b></p>

<ol style='margin-top:0in' start=2 type=1>
 <li class=MsoNormal>If both Thread1 Flag and Thread2 Flag are True in Version
     3, what is the resulting state?</li>
</ol>

<p class=MsoNormal>A) Thread1 proceeds</p>

<p class=MsoNormal>B) Thread2 proceeds</p>

<p class=MsoNormal>C) Deadlock is possible 72</p>

<p class=MsoNormal>D) Mutual exclusion is violated</p>

<p class=MsoNormal><b>Answer: C) Deadlock is possible</b></p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Numerical Example (State Analysis)</b></p>

<p class=MsoNormal>The slide's table summarizes the states<sup>73</sup>:</p>

<table class=MsoNormalTable border=0 cellspacing=3 cellpadding=0>
 <thead>
  <tr>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Step</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Thread1 Flag</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Thread2 Flag</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Who Proceeds</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Why</b></p>
   </td>
  </tr>
 </thead>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>4</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>T</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>T</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>None</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Deadlock possible <sup>74</sup></p>
  </td>
 </tr>
</table>

<p class=MsoNormal>If both threads set their respective flags to true and then
both execute the while loop (checking the other's true flag), neither proceeds,
resulting in a deadlock.</p>

<p class=MsoNormal><b>Slide 11-12: Peterson's Algorithm</b></p>

<p class=MsoNormal><b>Explanation</b></p>

<p class=MsoNormal><b>Peterson's Algorithm</b> is a classic software solution
for the two-process critical section problem that correctly satisfies all three
conditions: <b>Mutual Exclusion, Progress, and Bounded Waiting</b><sup>75</sup>.</p>

<p class=MsoNormal>It uses two shared variables<sup>76</sup>:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>Flags (flag[2])</b>: Boolean array to signal a thread's
     <b>intention to enter</b> the CS (flag[i] = true means &quot;I want to
     enter&quot;)<sup>77</sup>.</li>
 <li class=MsoNormal><b>Turn (turn)</b>: An integer variable that acts as a <b>tie-breaker</b>
     if both threads want to enter simultaneously (&quot;Whose turn is it to go
     first?&quot;)<sup>78</sup>.</li>
</ol>

<p class=MsoNormal><b>Entry Section Logic (for $\text{P0}$)</b>:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Sets intention: $\text{flag}[0] = \text{true}$.</li>
 <li class=MsoNormal>Defers to the opponent: $\text{turn} = 1$. (Tries to give
     priority to P1)</li>
 <li class=MsoNormal>Waits <i>only if</i> the opponent still wants to enter <b>AND</b>
     it is the opponent's turn: while (flag[1] &amp;&amp; turn == 1)<sup>79</sup>.</li>
</ol>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Mutual Exclusion</b>: Both cannot be inside the CS
     simultaneously; one always backs off based on the turn variable<sup>80</sup>.</li>
 <li class=MsoNormal><b>Progress</b>: If no one is in the CS and one thread
     wants to enter, it can enter immediately<sup>81</sup>.</li>
 <li class=MsoNormal><b>Bounded Waiting (Fairness)</b>: If both threads
     continuously want the CS, they alternate based on the turn variable,
     preventing starvation<sup>82</sup>.</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Use Cases</b></p>

<table class=MsoNormalTable border=0 cellspacing=3 cellpadding=0>
 <thead>
  <tr>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Concept</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Use Case</b></p>
   </td>
  </tr>
 </thead>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Peterson's Algorithm</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>An ideal, elegant example to prove that mutual exclusion
  can be achieved using only <b>basic memory operations</b> (loads and stores)
  without needing complex atomic hardware instructions.</p>
  </td>
 </tr>
</table>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>In Peterson's Algorithm, what is the primary role of the
     turn variable?</li>
</ol>

<p class=MsoNormal>A) To count how many times a process has entered the
critical section.</p>

<p class=MsoNormal>B) To act as a tie-breaker when both processes want to enter
the critical section simultaneously. 83</p>

<p class=MsoNormal>C) To signal a process's intention to enter the critical
section.</p>

<p class=MsoNormal>D) To enforce strict alternation between the two processes.</p>

<p class=MsoNormal><b>Answer: B) To act as a tie-breaker when both processes
want to enter the critical section simultaneously.</b></p>

<ol style='margin-top:0in' start=2 type=1>
 <li class=MsoNormal>What condition does Peterson's Algorithm satisfy that
     Dekker's Version 3 does not?</li>
</ol>

<p class=MsoNormal>A) Mutual Exclusion</p>

<p class=MsoNormal>B) Progress</p>

<p class=MsoNormal>C) Bounded Waiting (Fairness) 84</p>

<p class=MsoNormal>D) Use of a flag variable</p>

<p class=MsoNormal><b>Answer: C) Bounded Waiting (Fairness)</b></p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Numerical Example (Tie-breaker Logic)</b></p>

<p class=MsoNormal>Consider the state where both P0 and P1 want to enter the CS
and execute up to the turn setting line:</p>

<table class=MsoNormalTable border=0 cellspacing=3 cellpadding=0>
 <thead>
  <tr>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Event</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>P0 Action</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>P1 Action</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>flag[0]</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>flag[1]</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>turn</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Who Enters?</b></p>
   </td>
  </tr>
 </thead>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>1</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>$\text{flag}[0] = \text{true}$</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>$\text{flag}[1] = \text{true}$</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>T</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>T</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Undefined (e.g., 0)</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>-</p>
  </td>
 </tr>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>2</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>$\text{turn} = 1$</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>-</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>T</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>T</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>1</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>-</p>
  </td>
 </tr>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>3</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>-</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>$\text{turn} = 0$</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>T</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>T</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>0</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>-</p>
  </td>
 </tr>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>4</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Check Wait</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Check Wait</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>T</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>T</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>0</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>-</p>
  </td>
 </tr>
</table>

<p class=MsoNormal><b>Wait Check</b> ($\text{turn} = 0$):</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>P0's Wait</b>: $\text{while} (\text{flag}[1] \text{
     \&amp;\&amp; } \text{turn} == 1)$. Since $\text{turn} = 0$, the condition
     is False. <b>P0 proceeds</b>.</li>
 <li class=MsoNormal><b>P1's Wait</b>: $\text{while} (\text{flag}[0] \text{
     \&amp;\&amp; } \text{turn} == 0)$. Since $\text{flag}[0] = \text{true}$
     and $\text{turn} = 0$, the condition is True. <b>P1 waits</b>.</li>
</ul>

<p class=MsoNormal>The last thread to set the turn variable (P1, setting $\text{turn}=0$)
effectively yields priority to the opponent (P0), ensuring only one proceeds.</p>

<p class=MsoNormal><b>Slide 13: __syncthreads() (Barrier)</b></p>

<p class=MsoNormal><b>Explanation</b></p>

<p class=MsoNormal>__syncthreads() acts as a <b>block-level barrier</b> in GPU
(CUDA) programming<sup>8585</sup>.</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Purpose</b>: It ensures that <b>all threads in the same
     thread block</b> reach this point in the code before <i>any</i> thread in
     that block can proceed further<sup>86868686</sup>.</li>
 <li class=MsoNormal><b>Key Effect</b>: It guarantees <b>memory consistency</b>
     in <b>shared memory</b><sup>87</sup>. It makes sure that any writes to
     shared memory performed by threads before the barrier are fully visible to
     all other threads in the block after the barrier<sup>888888</sup>.</li>
 <li class=MsoNormal><b>Consequence of Omission</b>: Without it, some threads
     might read outdated data or overwrite shared memory before other threads
     have finished reading it<sup>89</sup>.</li>
 <li class=MsoNormal><b>Scope</b>: This synchronization is <b>only</b>
     effective <b>within a single block</b>, not across different blocks<sup>90909090909090</sup>.</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Use Cases</b></p>

<table class=MsoNormalTable border=0 cellspacing=3 cellpadding=0>
 <thead>
  <tr>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Concept</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Use Case</b></p>
   </td>
  </tr>
 </thead>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>__syncthreads()</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Tiled Matrix Multiplication</b>: Used after loading a
  tile of data from global memory into shared memory, ensuring all data is
  ready before computation starts.</p>
  </td>
 </tr>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Data Reduction</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Used in a reduction loop after each addition step in
  shared memory, guaranteeing all threads have completed the step before moving
  to the next one<sup>91</sup>.</p>
  </td>
 </tr>
</table>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>The __syncthreads() barrier guarantees memory consistency
     for which type of memory?</li>
</ol>

<p class=MsoNormal>A) Global memory</p>

<p class=MsoNormal>B) Shared memory (within a block) 92</p>

<p class=MsoNormal>C) Constant memory</p>

<p class=MsoNormal>D) Local memory</p>

<p class=MsoNormal><b>Answer: B) Shared memory (within a block)</b></p>

<ol style='margin-top:0in' start=2 type=1>
 <li class=MsoNormal>If one thread in a block reaches a __syncthreads() call,
     what happens to that thread?</li>
</ol>

<p class=MsoNormal>A) It proceeds to the next line immediately.</p>

<p class=MsoNormal>B) It waits until all threads in the same block have also
reached the barrier. 93939393</p>

<p class=MsoNormal>C) It causes a deadlock.</p>

<p class=MsoNormal>D) It begins communicating with other blocks.</p>

<p class=MsoNormal><b>Answer: B) It waits until all threads in the same block
have also reached the barrier.</b></p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Numerical Example (Illustrative)</b></p>

<p class=MsoNormal>A reduction kernel uses shared memory to sum up elements.
The synchronization is essential for correctness:</p>

<p class=MsoNormal>C</p>

<p class=MsoNormal>// Load input into shared memory</p>

<p class=MsoNormal>sdata[tid] = input[i]; </p>

<p class=MsoNormal>__syncthreads(); // Barrier 1: Ensure all sdata is written
[cite: 204]</p>

<p class=MsoNormal>for (int stride = blockDim.x / 2; stride &gt; 0; stride
&gt;&gt;= 1) {</p>

<p class=MsoNormal>    if (tid &lt; stride)</p>

<p class=MsoNormal>        sdata[tid] += sdata[tid + stride]; // e.g., tid 0
adds from tid 1</p>

<p class=MsoNormal>    __syncthreads(); // Barrier 2: Ensure addition result is
visible before next stride [cite: 206]</p>

<p class=MsoNormal>}</p>

<p class=MsoNormal>Without <b>Barrier 2</b>, the thread at $\text{tid}=0$ in
the next iteration (stride = 1) might read the value from $\text{sdata}[1]$
before the thread at $\text{tid}=1$ has finished writing its updated sum from
the current iteration (stride = 2).</p>

<p class=MsoNormal><b>Slide 14 &amp; 16: GPU Equivalent of Dekker’s Algorithm:
Atomic Compare-and-Swap (atomicCAS)</b></p>

<p class=MsoNormal><b>Explanation</b></p>

<p class=MsoNormal>The GPU equivalent of Dekker's Algorithm uses <b>atomic
operations</b>, specifically atomicCAS (Atomic Compare-and-Swap), to implement
a simple lock for mutual exclusion<sup>94</sup>.</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>atomicCAS(lock, old_val, new_val)</b>: This function is
     an atomic operation that checks if the value at the address lock is equal
     to old_val. If it is, it atomically writes new_val to lock and returns the
     <i>original</i> value of lock. If it's not equal, it returns the current
     value of lock without writing.</li>
 <li class=MsoNormal><b>Lock Acquisition (acquire_lock)</b>:</li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>The while loop runs: while (atomicCAS(lock, 0, 1) != 0);<sup>95</sup>.</li>
  <li class=MsoNormal>The thread attempts to change the lock value from <b>0
      (free)</b> to <b>1 (locked)</b>.</li>
  <li class=MsoNormal>It only succeeds if the lock was originally 0. The
      function returns 0, the while condition is false, and the thread enters
      the CS.</li>
  <li class=MsoNormal>If the lock was already 1, the function returns 1. The while
      condition is true, and the thread <b>spins/busy-waits</b> by repeatedly
      trying the atomicCAS until the lock is released<sup>969696</sup>.</li>
 </ul>
 <li class=MsoNormal><b>Lock Release (release_lock)</b>:</li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>atomicExch(lock, 0) simply sets the lock back to <b>0
      (free)</b> atomically<sup>97</sup>.</li>
 </ul>
 <li class=MsoNormal><b>Scope</b>: This mechanism works <b>across global memory
     (device-wide)</b>, meaning it can enforce mutual exclusion between threads
     in different blocks<sup>98989898</sup>.</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Use Cases</b></p>

<table class=MsoNormalTable border=0 cellspacing=3 cellpadding=0>
 <thead>
  <tr>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Concept</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Use Case</b></p>
   </td>
  </tr>
 </thead>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>atomicCAS()</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'></td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Implementing Locks (Mutexes)</b> for critical sections
  in GPU code<sup>99</sup>.</p>
  </td>
 </tr>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Safe Global Counter</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Incrementing a single, shared global counter variable from
  multiple blocks/threads<sup>100</sup>.</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'></td>
 </tr>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Shared Data Structure</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Updating a shared linked list or a priority queue
  structure in global memory.</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'></td>
 </tr>
</table>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>The GPU locking mechanism based on atomicCAS operates over
     which memory scope?</li>
</ol>

<p class=MsoNormal>A) Shared memory (within a block)</p>

<p class=MsoNormal>B) Global memory (device-wide) 101101101101</p>

<p class=MsoNormal>C) Constant memory</p>

<p class=MsoNormal>D) Local memory</p>

<p class=MsoNormal><b>Answer: B) Global memory (device-wide)</b></p>

<ol style='margin-top:0in' start=2 type=1>
 <li class=MsoNormal>In the acquire_lock function, if atomicCAS(lock, 0, 1)
     returns 1, what does the calling thread do?</li>
</ol>

<p class=MsoNormal>A) Proceeds to the critical section.</p>

<p class=MsoNormal>B) Immediately releases the lock.</p>

<p class=MsoNormal>C) Enters a busy-wait (spin) loop. 102102102</p>

<p class=MsoNormal>D) Calls __syncthreads().</p>

<p class=MsoNormal><b>Answer: C) Enters a busy-wait (spin) loop.</b></p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Numerical Example (Lock Acquisition)</b></p>

<p class=MsoNormal>Initial lock value: $\text{lock} = 0$.</p>

<table class=MsoNormalTable border=0 cellspacing=3 cellpadding=0>
 <thead>
  <tr>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Thread</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>atomicCAS(lock, 0, 1) Return Value</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Lock Value after CAS</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Action</b></p>
   </td>
  </tr>
 </thead>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Thread 0 (Succeeds)</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>0</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>1</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Exits while loop $\to$ <b>Enters CS</b> <sup>103</sup></p>
  </td>
 </tr>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Thread 1 (Fails)</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>1 (The current lock value)</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>1</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'></td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>while loop condition is True $\to$ <b>Busy-waits</b> <sup>104</sup></p>
  </td>
 </tr>
</table>

<p class=MsoNormal>Once Thread 0 calls release_lock ($\text{atomicExch(lock,
0)}$), the lock value becomes 0, and the next waiting thread can successfully
execute atomicCAS(lock, 0, 1).</p>

<p class=MsoNormal><b>Slide 17-18: Comparisons</b></p>

<p class=MsoNormal><b>Explanation</b></p>

<p class=MsoNormal>These slides provide a clear comparison between the two main
GPU synchronization primitives: __syncthreads() and atomicCAS().</p>

<table class=MsoNormalTable border=0 cellspacing=3 cellpadding=0>
 <thead>
  <tr>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Aspect</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>__syncthreads()</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>atomicCAS()</b></p>
   </td>
  </tr>
 </thead>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Purpose</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'></td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Barrier synchronization</b><sup>105105</sup>. All
  threads in a block must stop and wait for each other<sup>106106106106</sup>.</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'></td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Mutual exclusion (locking)</b><sup>107107</sup>. Ensures
  only one thread at a time accesses a shared resource<sup>108108</sup>.</p>
  </td>
 </tr>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Scope</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'></td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Within a single block</b><sup>109109109109</sup>.</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'></td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Across global memory (device-wide)</b><sup>110110110110</sup>.</p>
  </td>
 </tr>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Synchronization Type</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'></td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Collective</b> (everyone waits)<sup>111111</sup>.</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'></td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Exclusive</b> (one at a time)<sup>112112</sup>.</p>
  </td>
 </tr>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Common Use</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Coordinating <b>shared memory access</b> inside a block,
  like in tiled matrix multiplication<sup>113113113113</sup>.</p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Safe <b>global memory access</b> (e.g., incrementing a
  global counter, implementing locks)<sup>114</sup>.</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'></td>
  <td style='padding:.75pt .75pt .75pt .75pt'></td>
 </tr>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>Visual Metaphor</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>&quot;Everyone stops at a red light until all
  arrive.&quot; <sup>115115</sup></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>&quot;One person uses the restroom at a time.&quot; <sup>116116</sup></p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'></td>
  <td style='padding:.75pt .75pt .75pt .75pt'></td>
 </tr>
</table>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Use Cases</b></p>

<table class=MsoNormalTable border=0 cellspacing=3 cellpadding=0>
 <thead>
  <tr>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Function</b></p>
   </td>
   <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>When to Use</b></p>
   </td>
  </tr>
 </thead>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>__syncthreads()</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>When you need to ensure <b>all</b> threads in a block have
  completed a step (e.g., loading data to shared memory) before the next step
  begins<sup>117117</sup>.</p>
  </td>
 </tr>
 <tr>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><b>atomicCAS()</b></p>
  </td>
  <td style='border:solid windowtext 1.0pt;padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>When multiple threads, potentially from different blocks,
  may update the <b>same global variable</b> or data structure, requiring a
  lock or an atomic update<sup>118</sup>.</p>
  </td>
 </tr>
</table>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Which synchronization primitive is used to enforce mutual
     exclusion across threads belonging to different blocks?</li>
</ol>

<p class=MsoNormal>A) __syncthreads()</p>

<p class=MsoNormal>B) atomicCAS() 119119119119</p>

<p class=MsoNormal>C) Both</p>

<p class=MsoNormal>D) Neither</p>

<p class=MsoNormal><b>Answer: B) atomicCAS()</b></p>

<ol style='margin-top:0in' start=2 type=1>
 <li class=MsoNormal>The purpose of __syncthreads() is best described as:</li>
</ol>

<p class=MsoNormal>A) Mutual exclusion</p>

<p class=MsoNormal>B) Exclusive update</p>

<p class=MsoNormal>C) Barrier synchronization 120120</p>

<p class=MsoNormal>D) Safe global memory access</p>

<p class=MsoNormal><b>Answer: C) Barrier synchronization</b></p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Numerical Example (Conceptual)</b></p>

<p class=MsoNormal>If a problem requires threads from <b>different blocks</b>
to safely increment a <b>global result counter</b>, you must use an <b>exclusive</b>
mechanism like atomicCAS() (Scope: Across blocks)<sup>121</sup>.</p>

<p class=MsoNormal>If a problem requires threads within the <b>same block</b>
to load a tile of data into <b>shared memory</b> and ensure all threads see the
complete data set before starting computation, you must use a <b>collective</b>
mechanism like __syncthreads() (Scope: Within a single block)<sup>122122122122</sup></p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<div style='border:none;border-bottom:double windowtext 2.25pt;padding:0in 0in 1.0pt 0in'>

<p class=MsoNormal style='border:none;padding:0in'>&nbsp;</p>

</div>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal><b>GPU Programming Lecture 10 - Comprehensive Guide</b></p>

<p class=MsoNormal><b>Slide 1: Title Slide</b></p>

<p class=MsoNormal><b>Explanation:</b> This lecture focuses on synchronization
in GPU programming - how to coordinate multiple threads working together
safely.</p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 2: Critical Section</b></p>

<p class=MsoNormal><b>Easy Explanation:</b> Imagine a bathroom with one door.
If multiple people try to use it at the same time, chaos happens! A critical
section is like that bathroom - it's a piece of code where only ONE thread
should work at a time because they're all touching the same shared data (like a
counter or variable). If multiple threads enter together, they mess up each
other's work, causing &quot;race conditions&quot; - unpredictable, wrong
results.</p>

<p class=MsoNormal><b>Three Required Conditions:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>Mutual Exclusion</b>: Only one thread in the critical
     section at a time</li>
 <li class=MsoNormal><b>Progress</b>: If no one is inside, someone waiting
     should be able to enter</li>
 <li class=MsoNormal><b>Bounded Waiting</b>: No thread should wait forever</li>
</ol>

<p class=MsoNormal><b>MCQs:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>What is a critical section? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) Code that runs very fast</li>
  <li class=MsoNormal>b) Code where shared resources are accessed and only one
      thread should execute at a time &#10003;</li>
  <li class=MsoNormal>c) Code with syntax errors</li>
  <li class=MsoNormal>d) Code that uses lots of memory</li>
 </ul>
 <li class=MsoNormal>Which is NOT a requirement for solving critical section
     problems? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) Mutual Exclusion</li>
  <li class=MsoNormal>b) Progress</li>
  <li class=MsoNormal>c) Maximum Speed &#10003;</li>
  <li class=MsoNormal>d) Bounded Waiting</li>
 </ul>
 <li class=MsoNormal>What happens if multiple threads enter a critical section
     simultaneously? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) Better performance</li>
  <li class=MsoNormal>b) Race conditions and incorrect results &#10003;</li>
  <li class=MsoNormal>c) Automatic synchronization</li>
  <li class=MsoNormal>d) Nothing special</li>
 </ul>
</ol>

<p class=MsoNormal><b>Use Cases:</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Updating a shared counter (like counting website visitors)</li>
 <li class=MsoNormal>Modifying a shared data structure (like a queue or list)</li>
 <li class=MsoNormal>Writing to the same file from multiple threads</li>
 <li class=MsoNormal>Updating account balance in banking software</li>
</ul>

<p class=MsoNormal><b>Numericals:</b> <b>Problem 1:</b> If 5 threads each need
to spend 10ms in a critical section, and they must enter one at a time, what's
the minimum total time needed?</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Answer:</b> 5 × 10ms = 50ms (sequential execution)</li>
</ul>

<p class=MsoNormal><b>Problem 2:</b> Without synchronization, 3 threads each
increment a counter from 0. Each does 100 increments. What's the expected
result WITH proper synchronization vs possible result WITHOUT?</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>With synchronization:</b> 300 (correct)</li>
 <li class=MsoNormal><b>Without synchronization:</b> Anywhere from 3 to 300
     (unpredictable due to race conditions)</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 3: Data Race Example</b></p>

<p class=MsoNormal><b>Easy Explanation:</b> This shows WHY we need critical
sections. Two threads try to increment a counter simultaneously:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Both read counter = 0</li>
 <li class=MsoNormal>Both calculate 0 + 1 = 1</li>
 <li class=MsoNormal>Both write 1 back</li>
 <li class=MsoNormal>Result: counter = 1 (should be 2!)</li>
</ul>

<p class=MsoNormal>This is like two people checking a shared bank account
balance ($100), both seeing $100, both depositing $50, but the final balance
shows $150 instead of $200 because they overwrote each other's changes.</p>

<p class=MsoNormal><b>MCQs:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>In the example, what should the final counter value be if
     two threads each increment once? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) 1</li>
  <li class=MsoNormal>b) 2 &#10003;</li>
  <li class=MsoNormal>c) 0</li>
  <li class=MsoNormal>d) 3</li>
 </ul>
 <li class=MsoNormal>Why does the counter end up as 1 instead of 2? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) The code has a syntax error</li>
  <li class=MsoNormal>b) Both threads read the same initial value before either
      writes back &#10003;</li>
  <li class=MsoNormal>c) Only one thread executed</li>
  <li class=MsoNormal>d) The counter was initialized incorrectly</li>
 </ul>
 <li class=MsoNormal>What is this problem called? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) Deadlock</li>
  <li class=MsoNormal>b) Race condition &#10003;</li>
  <li class=MsoNormal>c) Memory leak</li>
  <li class=MsoNormal>d) Buffer overflow</li>
 </ul>
</ol>

<p class=MsoNormal><b>Use Cases:</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Online ticket booking (two people buying the last seat)</li>
 <li class=MsoNormal>Inventory management (two orders for the last item)</li>
 <li class=MsoNormal>Like/upvote counters on social media</li>
 <li class=MsoNormal>Download counters on websites</li>
</ul>

<p class=MsoNormal><b>Numericals:</b> <b>Problem 1:</b> 10 threads each
increment a counter 1000 times without synchronization. What's the:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Expected correct result:</b> 10 × 1000 = 10,000</li>
 <li class=MsoNormal><b>Possible actual result:</b> Anywhere from 1000 to
     10,000 (unpredictable)</li>
</ul>

<p class=MsoNormal><b>Problem 2:</b> Operation breakdown for counter++:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Read: 1 cycle</li>
 <li class=MsoNormal>Add: 1 cycle</li>
 <li class=MsoNormal>Write: 1 cycle</li>
 <li class=MsoNormal>Total: 3 cycles</li>
</ul>

<p class=MsoNormal>If 2 threads overlap completely, how many operations
actually execute?</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Answer:</b> 6 operations total, but final result
     reflects only 1 increment instead of 2</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 4 &amp; 5: Dekker's Algorithm - Version 1</b></p>

<p class=MsoNormal><b>Easy Explanation:</b> This is like a &quot;talking
stick&quot; system. There's a variable thread_no that says whose turn it is.
Thread1 waits until thread_no == 1, does its work, then sets thread_no = 2 to
give Thread2 a turn. Thread2 does the same in reverse.</p>

<p class=MsoNormal><b>Problem:</b> Strict alternation. Even if Thread1 wants to
run 10 times and Thread2 isn't ready, Thread1 must wait for Thread2's turn.
It's like forcing people to take turns on a slide even when only one person
wants to use it.</p>

<p class=MsoNormal><b>MCQs:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>In Version 1, what allows a thread to enter its critical
     section? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) Random chance</li>
  <li class=MsoNormal>b) The thread_no variable matching its ID &#10003;</li>
  <li class=MsoNormal>c) Being the fastest</li>
  <li class=MsoNormal>d) First come first served</li>
 </ul>
 <li class=MsoNormal>What's the main problem with Version 1? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) It doesn't provide mutual exclusion</li>
  <li class=MsoNormal>b) It forces strict alternation even when unnecessary
      &#10003;</li>
  <li class=MsoNormal>c) It causes deadlock</li>
  <li class=MsoNormal>d) It's too complex</li>
 </ul>
 <li class=MsoNormal>What does the while loop do? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) Executes the critical section</li>
  <li class=MsoNormal>b) Busy-waits until it's the thread's turn &#10003;</li>
  <li class=MsoNormal>c) Causes errors</li>
  <li class=MsoNormal>d) Speeds up execution</li>
 </ul>
</ol>

<p class=MsoNormal><b>Use Cases:</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Simple two-process systems where equal turns are needed</li>
 <li class=MsoNormal>Educational purposes to understand synchronization</li>
 <li class=MsoNormal>Systems where balanced execution is required</li>
 <li class=MsoNormal>Round-robin resource sharing</li>
</ul>

<p class=MsoNormal><b>Numericals:</b> <b>Problem 1:</b> Thread1 needs CS 3
times, Thread2 needs it 1 time. Each CS takes 5ms. Total time?</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Answer:</b> 4 alternations × 5ms = 20ms (even though
     Thread2 only needed 1 turn)</li>
</ul>

<p class=MsoNormal><b>Problem 2:</b> If Thread1 wants to run 100 times but
Thread2 is stuck/slow and only runs once every 10 seconds:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Time for Thread1 to complete:</b> 100 × 10 seconds =
     1000 seconds (very inefficient!)</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 6: Explanation (Version 1)</b></p>

<p class=MsoNormal><b>Easy Explanation:</b> This slide visualizes the strict
turn-taking. It's like a tennis match where players must alternate serves, even
if one player isn't ready.</p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 7 &amp; 8: Dekker's Algorithm - Version 2</b></p>

<p class=MsoNormal><b>Easy Explanation:</b> Now each thread has its own flag
(like putting your hand up). Before entering CS, a thread checks if the OTHER
thread's flag is up. If yes, wait. If no, raise your own flag and enter.</p>

<p class=MsoNormal><b>Problem - DEADLOCK:</b> Both threads can raise their
flags simultaneously, then both wait for the other to lower their flag. Neither
can proceed - they're stuck forever! It's like two people at a doorway, both
saying &quot;after you&quot; indefinitely.</p>

<p class=MsoNormal><b>MCQs:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>What do the flags (th1, th2) indicate? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) Thread speed</li>
  <li class=MsoNormal>b) Whether a thread is in or wants to enter the critical
      section &#10003;</li>
  <li class=MsoNormal>c) Thread priority</li>
  <li class=MsoNormal>d) Thread completion status</li>
 </ul>
 <li class=MsoNormal>What's the critical flaw in Version 2? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) No mutual exclusion</li>
  <li class=MsoNormal>b) Possible deadlock if both set flags simultaneously
      &#10003;</li>
  <li class=MsoNormal>c) Too slow</li>
  <li class=MsoNormal>d) Uses too much memory</li>
 </ul>
 <li class=MsoNormal>When does Thread1 wait? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) When th1 is true</li>
  <li class=MsoNormal>b) When th2 is true &#10003;</li>
  <li class=MsoNormal>c) Always</li>
  <li class=MsoNormal>d) Never</li>
 </ul>
</ol>

<p class=MsoNormal><b>Use Cases:</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Demonstrates why synchronization is tricky</li>
 <li class=MsoNormal>Educational example of deadlock scenarios</li>
 <li class=MsoNormal>NOT recommended for production use</li>
 <li class=MsoNormal>Shows importance of proper flag ordering</li>
</ul>

<p class=MsoNormal><b>Numericals:</b> <b>Problem 1:</b> Probability of deadlock
if both threads start simultaneously and flag-setting takes 1ns:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>If timing is exactly synchronized: <b>100% deadlock</b></li>
 <li class=MsoNormal>With slight variations: <b>Lower but still possible</b></li>
</ul>

<p class=MsoNormal><b>Problem 2:</b> In a system running for 1 hour with
threads attempting CS entry every 1ms:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Attempts per thread: 3,600,000</li>
 <li class=MsoNormal>If 0.01% chance of simultaneous flag setting: <b>360
     potential deadlocks per hour</b></li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 9 &amp; 10: Dekker's Algorithm - Version 3</b></p>

<p class=MsoNormal><b>Easy Explanation:</b> This version sets the flag BEFORE
checking the other thread's flag. Now both threads announce their intention
first, then check each other.</p>

<p class=MsoNormal><b>Still has the deadlock problem!</b> Both can set their
flags to true, then both check and find the other wants in, so both wait
forever.</p>

<p class=MsoNormal><b>MCQs:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>What's the key difference between Version 2 and Version 3?
     </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) Number of flags used</li>
  <li class=MsoNormal>b) Flag is set before the check instead of after &#10003;</li>
  <li class=MsoNormal>c) No difference</li>
  <li class=MsoNormal>d) Version 3 uses atomic operations</li>
 </ul>
 <li class=MsoNormal>Does Version 3 solve the deadlock problem? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) Yes, completely</li>
  <li class=MsoNormal>b) No, deadlock is still possible &#10003;</li>
  <li class=MsoNormal>c) Only sometimes</li>
  <li class=MsoNormal>d) Only for more than 2 threads</li>
 </ul>
 <li class=MsoNormal>What does &quot;wantstoenter&quot; flag represent? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) Thread has completed</li>
  <li class=MsoNormal>b) Thread is requesting entry to critical section
      &#10003;</li>
  <li class=MsoNormal>c) Thread priority</li>
  <li class=MsoNormal>d) Thread ID</li>
 </ul>
</ol>

<p class=MsoNormal><b>Use Cases:</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Shows evolution of synchronization algorithms</li>
 <li class=MsoNormal>Educational purposes</li>
 <li class=MsoNormal>Demonstrates that order of operations matters</li>
 <li class=MsoNormal>NOT suitable for production (deadlock risk)</li>
</ul>

<p class=MsoNormal><b>Numericals:</b> <b>Problem 1:</b> With 1000 threads using
Version 3, what's the worst case?</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>All 1000 could deadlock</b> if they all set flags
     simultaneously</li>
</ul>

<p class=MsoNormal><b>Problem 2:</b> If deadlock occurs, how much CPU time is
wasted?</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>100% of CPU cycles</b> spent on busy-waiting (spinning
     in the while loop)</li>
 <li class=MsoNormal>No useful work done until system is reset</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 11 &amp; 12: Peterson's Algorithm</b></p>

<p class=MsoNormal><b>Easy Explanation:</b> Peterson's Algorithm combines BOTH
approaches:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>Flags</b>: Each thread announces intention (like
     Version 2/3)</li>
 <li class=MsoNormal><b>Turn variable</b>: Acts as a tie-breaker (like Version
     1)</li>
</ol>

<p class=MsoNormal>The magic: When both want in, one thread YIELDS by setting
turn to the OTHER thread's ID. This breaks the deadlock! It's like both people
at the door saying &quot;after you,&quot; but one actually steps back.</p>

<p class=MsoNormal><b>Key insight:</b> A thread says &quot;I want to
enter&quot; (flag), but also &quot;You can go first if we both want in&quot;
(turn = other thread).</p>

<p class=MsoNormal><b>MCQs:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Peterson's Algorithm uses: </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) Only flags</li>
  <li class=MsoNormal>b) Only turn variable</li>
  <li class=MsoNormal>c) Both flags and turn variable &#10003;</li>
  <li class=MsoNormal>d) Neither</li>
 </ul>
 <li class=MsoNormal>What breaks the deadlock in Peterson's Algorithm? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) Random timing</li>
  <li class=MsoNormal>b) The turn variable acts as a tie-breaker &#10003;</li>
  <li class=MsoNormal>c) One thread is faster</li>
  <li class=MsoNormal>d) Operating system intervention</li>
 </ul>
 <li class=MsoNormal>The turn variable represents: </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) How many turns each thread has taken</li>
  <li class=MsoNormal>b) Which thread gets priority when both want to enter
      &#10003;</li>
  <li class=MsoNormal>c) Thread execution order</li>
  <li class=MsoNormal>d) Number of threads</li>
 </ul>
</ol>

<p class=MsoNormal><b>Use Cases:</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Classic solution for two-process mutual exclusion</li>
 <li class=MsoNormal>Academic teaching of synchronization</li>
 <li class=MsoNormal>Simple embedded systems with two processes</li>
 <li class=MsoNormal>Historical importance in OS design</li>
</ul>

<p class=MsoNormal><b>Numericals:</b> <b>Problem 1:</b> Two threads using
Peterson's Algorithm each need CS 100 times. Each CS takes 2ms. What's the
best-case total time?</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Answer:</b> 200 × 2ms = 400ms (proper alternation
     without deadlock)</li>
</ul>

<p class=MsoNormal><b>Problem 2:</b> Compare Peterson's vs Version 1:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Version 1:</b> Forces alternation, could waste time</li>
 <li class=MsoNormal><b>Peterson's:</b> Allows back-to-back execution by same
     thread if other isn't ready</li>
 <li class=MsoNormal><b>Efficiency gain:</b> Up to 50% better when workload is
     unbalanced</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 13: __syncthreads() (barrier)</b></p>

<p class=MsoNormal><b>Easy Explanation:</b> __syncthreads() is like a
checkpoint in a race. ALL threads in a block must reach this point before ANY
can continue. It's used to ensure everyone has finished their part of the work
before moving to the next stage.</p>

<p class=MsoNormal><b>Example:</b> In the code, threads first load data into
shared memory. __syncthreads() ensures everyone has finished loading before
anyone starts reading. Otherwise, Thread 0 might try to read Thread 5's data
before Thread 5 has written it!</p>

<p class=MsoNormal><b>MCQs:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>What does __syncthreads() do? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) Speeds up thread execution</li>
  <li class=MsoNormal>b) Makes all threads in a block wait until all reach this
      point &#10003;</li>
  <li class=MsoNormal>c) Synchronizes across all blocks</li>
  <li class=MsoNormal>d) Deletes threads</li>
 </ul>
 <li class=MsoNormal>Why is __syncthreads() needed after loading shared memory?
     </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) To save memory</li>
  <li class=MsoNormal>b) To ensure all threads have written their data before
      anyone reads &#10003;</li>
  <li class=MsoNormal>c) To speed up loads</li>
  <li class=MsoNormal>d) It's not necessary</li>
 </ul>
 <li class=MsoNormal>What's the scope of __syncthreads()? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) Single thread</li>
  <li class=MsoNormal>b) Within one block only &#10003;</li>
  <li class=MsoNormal>c) Entire GPU</li>
  <li class=MsoNormal>d) Across multiple GPUs</li>
 </ul>
</ol>

<p class=MsoNormal><b>Use Cases:</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Parallel reduction (summing array elements)</li>
 <li class=MsoNormal>Tiled matrix multiplication</li>
 <li class=MsoNormal>Shared memory algorithms</li>
 <li class=MsoNormal>Stencil computations</li>
 <li class=MsoNormal>Any algorithm using shared memory collaboration</li>
</ul>

<p class=MsoNormal><b>Numericals:</b> <b>Problem 1:</b> A block has 256
threads. 255 threads reach __syncthreads() in 1&#956;s, but thread 127 takes
10&#956;s. When does work resume?</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Answer:</b> At 10&#956;s (everyone waits for the
     slowest)</li>
</ul>

<p class=MsoNormal><b>Problem 2:</b> Reduction sum with 1024 elements, 256
threads:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Without __syncthreads(): <b>Race conditions, wrong result</b></li>
 <li class=MsoNormal>With __syncthreads(): <b>Correct result, takes
     log&#8322;(256) = 8 barrier synchronizations</b></li>
</ul>

<p class=MsoNormal><b>Problem 3:</b> If each __syncthreads() costs 5 cycles
overhead, what's the cost for a reduction with 512 threads?</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Stages:</b> log&#8322;(512) = 9</li>
 <li class=MsoNormal><b>Total overhead:</b> 9 × 5 = 45 cycles</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 14: GPU Equivalent - Atomic Compare-and-Swap</b></p>

<p class=MsoNormal><b>Easy Explanation:</b> atomicCAS() (Compare-And-Swap) is
like a smart lock. It checks if a value is what you expect, and if so, changes
it to a new value - ALL IN ONE ATOMIC OPERATION that can't be interrupted.</p>

<p class=MsoNormal><b>Example:</b> atomicCAS(lock, 0, 1) means:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>&quot;If lock is 0 (unlocked), change it to 1 (locked) and
     let me in&quot;</li>
 <li class=MsoNormal>Only ONE thread succeeds even if 1000 try simultaneously</li>
 <li class=MsoNormal>Others keep trying until the lock becomes 0 again</li>
</ul>

<p class=MsoNormal>This works across the ENTIRE GPU (all blocks), unlike __syncthreads()
which only works within one block.</p>

<p class=MsoNormal><b>MCQs:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>What does atomicCAS stand for? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) Atomic Calculation and Store</li>
  <li class=MsoNormal>b) Atomic Compare-and-Swap &#10003;</li>
  <li class=MsoNormal>c) Atomic Copy and Synchronize</li>
  <li class=MsoNormal>d) Atomic Clear and Set</li>
 </ul>
 <li class=MsoNormal>What's the scope of atomicCAS()? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) Single thread</li>
  <li class=MsoNormal>b) Single block</li>
  <li class=MsoNormal>c) Entire device (all blocks) &#10003;</li>
  <li class=MsoNormal>d) Single warp</li>
 </ul>
 <li class=MsoNormal>atomicCAS(lock, 0, 1) succeeds when: </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) lock is currently 1</li>
  <li class=MsoNormal>b) lock is currently 0 &#10003;</li>
  <li class=MsoNormal>c) Any time</li>
  <li class=MsoNormal>d) Never</li>
 </ul>
</ol>

<p class=MsoNormal><b>Use Cases:</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Implementing locks/mutexes on GPU</li>
 <li class=MsoNormal>Atomic counters across blocks</li>
 <li class=MsoNormal>Lock-free data structures</li>
 <li class=MsoNormal>Building queues, stacks on GPU</li>
 <li class=MsoNormal>Global synchronization primitives</li>
</ul>

<p class=MsoNormal><b>Numericals:</b> <b>Problem 1:</b> 10,000 threads all try atomicCAS(lock,
0, 1) simultaneously. How many succeed immediately?</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Answer:</b> Exactly 1 thread</li>
</ul>

<p class=MsoNormal><b>Problem 2:</b> A critical section takes 100 cycles. 1024
threads need to execute it using atomicCAS. What's the total time?</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Answer:</b> 1024 × 100 = 102,400 cycles (pure serial
     execution)</li>
 <li class=MsoNormal><b>Note:</b> Very inefficient! Avoid if possible.</li>
</ul>

<p class=MsoNormal><b>Problem 3:</b> atomicCAS overhead is 20 cycles. Compare
time for 100 unsynchronized increments vs 100 atomic increments:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Unsynchronized:</b> 100 cycles (but wrong result!)</li>
 <li class=MsoNormal><b>Atomic with lock:</b> 100 × 20 = 2,000 cycles (correct
     result)</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 15: Visualization of __syncthreads()</b></p>

<p class=MsoNormal><b>Easy Explanation:</b> The diagram shows threads doing
work independently, then all hitting a barrier (X marks), waiting for everyone,
then continuing together. It's like a group of hikers who agree to wait at each
checkpoint so nobody gets left behind.</p>

<p class=MsoNormal><b>MCQs:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>In the visualization, what do the X marks represent? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) Errors</li>
  <li class=MsoNormal>b) Threads waiting at the barrier &#10003;</li>
  <li class=MsoNormal>c) Completed threads</li>
  <li class=MsoNormal>d) Critical sections</li>
 </ul>
 <li class=MsoNormal>Can Thread 0 start work B before Thread 3 reaches the
     barrier? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) Yes</li>
  <li class=MsoNormal>b) No &#10003;</li>
  <li class=MsoNormal>c) Sometimes</li>
  <li class=MsoNormal>d) Only if it's faster</li>
 </ul>
 <li class=MsoNormal>After the barrier, what happens? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) Only one thread continues</li>
  <li class=MsoNormal>b) All threads proceed together &#10003;</li>
  <li class=MsoNormal>c) Threads restart</li>
  <li class=MsoNormal>d) Threads terminate</li>
 </ul>
</ol>

<p class=MsoNormal><b>Use Cases:</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Visual understanding of barrier synchronization</li>
 <li class=MsoNormal>Teaching parallel algorithm design</li>
 <li class=MsoNormal>Debugging synchronization issues</li>
 <li class=MsoNormal>Understanding performance bottlenecks</li>
</ul>

<p class=MsoNormal><b>Numericals:</b> <b>Problem 1:</b> 8 threads, work A
takes: 10, 12, 15, 18, 20, 22, 25, 30 cycles respectively. When can work B
start?</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Answer:</b> At 30 cycles (when the slowest thread
     arrives)</li>
</ul>

<p class=MsoNormal><b>Problem 2:</b> If barrier overhead is 5 cycles and 4
threads synchronize 10 times, what's total barrier cost?</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Answer:</b> 10 barriers × 5 cycles = 50 cycles overhead</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 16: Visualization of atomicCAS()</b></p>

<p class=MsoNormal><b>Easy Explanation:</b> Only ONE thread gets through the
lock at a time. Others spin-wait (keep trying in a loop) until the lock is
released. Unlike __syncthreads(), threads don't all proceed together - they
take turns one by one.</p>

<p class=MsoNormal>It's like a single-person bathroom: only one person inside,
others wait in line, each person enters when the previous one leaves.</p>

<p class=MsoNormal><b>MCQs:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>When Thread 0 is in the critical section, what are other
     threads doing? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) Also in critical section</li>
  <li class=MsoNormal>b) Spin-waiting (busy-waiting) &#10003;</li>
  <li class=MsoNormal>c) Sleeping</li>
  <li class=MsoNormal>d) Doing other work</li>
 </ul>
 <li class=MsoNormal>How is atomicCAS() different from __syncthreads()? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) atomicCAS allows one thread at a time, __syncthreads()
      synchronizes all &#10003;</li>
  <li class=MsoNormal>b) They're the same</li>
  <li class=MsoNormal>c) __syncthreads() is faster</li>
  <li class=MsoNormal>d) atomicCAS only works in one block</li>
 </ul>
 <li class=MsoNormal>What happens after Thread 0 releases the lock? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) All threads enter together</li>
  <li class=MsoNormal>b) Next thread acquires the lock and enters &#10003;</li>
  <li class=MsoNormal>c) Program ends</li>
  <li class=MsoNormal>d) Lock stays locked</li>
 </ul>
</ol>

<p class=MsoNormal><b>Use Cases:</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Understanding lock-based synchronization</li>
 <li class=MsoNormal>Avoiding over-use of atomic operations</li>
 <li class=MsoNormal>Performance analysis of mutual exclusion</li>
 <li class=MsoNormal>Designing efficient GPU algorithms</li>
</ul>

<p class=MsoNormal><b>Numericals:</b> <b>Problem 1:</b> 1000 threads, each
needs 50&#956;s in critical section using atomicCAS. Total time?</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Answer:</b> 1000 × 50&#956;s = 50,000&#956;s = 50ms
     (completely serial!)</li>
</ul>

<p class=MsoNormal><b>Problem 2:</b> While 1000 threads spin-wait, they waste:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>CPU cycles:</b> All spinning threads consume power and
     cycles</li>
 <li class=MsoNormal><b>Energy:</b> Proportional to wait time × number of
     waiting threads</li>
 <li class=MsoNormal><b>Better solution:</b> Reduce contention or avoid locks</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 17: Comparisons - When to Use Which</b></p>

<p class=MsoNormal><b>Easy Explanation:</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Use __syncthreads()</b>: When threads in a BLOCK need
     to coordinate (like sharing data in shared memory)</li>
 <li class=MsoNormal><b>Use atomicCAS()</b>: When threads ACROSS BLOCKS need to
     update the same global variable</li>
</ul>

<p class=MsoNormal>Think of it this way:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>__syncthreads(): Team meeting (everyone in the room
     synchronizes)</li>
 <li class=MsoNormal>atomicCAS(): Bathroom lock (anyone from anywhere can use
     it, but only one at a time)</li>
</ul>

<p class=MsoNormal><b>MCQs:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>For tiled matrix multiplication within a block, use: </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) atomicCAS()</li>
  <li class=MsoNormal>b) __syncthreads() &#10003;</li>
  <li class=MsoNormal>c) Neither</li>
  <li class=MsoNormal>d) Both</li>
 </ul>
 <li class=MsoNormal>For incrementing a global counter across all blocks, use: </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) atomicCAS() or atomicAdd() &#10003;</li>
  <li class=MsoNormal>b) __syncthreads()</li>
  <li class=MsoNormal>c) Neither</li>
  <li class=MsoNormal>d) Both</li>
 </ul>
 <li class=MsoNormal>Which is more efficient for block-local coordination? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) atomicCAS()</li>
  <li class=MsoNormal>b) __syncthreads() &#10003;</li>
  <li class=MsoNormal>c) Same efficiency</li>
  <li class=MsoNormal>d) Neither</li>
 </ul>
</ol>

<p class=MsoNormal><b>Use Cases:</b></p>

<p class=MsoNormal><b>__syncthreads():</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Matrix multiplication (tiled)</li>
 <li class=MsoNormal>Parallel scan/prefix sum</li>
 <li class=MsoNormal>Fast Fourier Transform (FFT)</li>
 <li class=MsoNormal>Image convolution with shared tiles</li>
</ul>

<p class=MsoNormal><b>atomicCAS():</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Global histogram computation</li>
 <li class=MsoNormal>Device-wide queue/stack</li>
 <li class=MsoNormal>Reference counting</li>
 <li class=MsoNormal>Global locks/semaphores</li>
</ul>

<p class=MsoNormal><b>Numericals:</b> <b>Problem 1:</b> Which is faster for 256
threads in one block summing local data?</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>__syncthreads():</b> ~5-10 cycles per barrier</li>
 <li class=MsoNormal><b>atomicCAS():</b> ~20-100 cycles per atomic operation</li>
 <li class=MsoNormal><b>Winner:</b> __syncthreads() by 2-20x</li>
</ul>

<p class=MsoNormal><b>Problem 2:</b> Memory location:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>__syncthreads():</b> Works with shared memory (fast,
     on-chip)</li>
 <li class=MsoNormal><b>atomicCAS():</b> Works with global memory (slower,
     off-chip)</li>
 <li class=MsoNormal><b>Latency difference:</b> ~100x</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 18: Comparisons Table</b></p>

<p class=MsoNormal><b>Easy Explanation:</b> This summary table compares the two
synchronization primitives:</p>

<table class=MsoNormalTable border=0 cellspacing=3 cellpadding=0>
 <thead>
  <tr>
   <td style='padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Feature</b></p>
   </td>
   <td style='padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>__syncthreads()</b></p>
   </td>
   <td style='padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>atomicCAS()</b></p>
   </td>
  </tr>
 </thead>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Scope</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Within one block</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Entire device</p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Purpose</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Barrier/coordination</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Mutual exclusion/locking</p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Memory</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Shared memory</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Global memory</p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Speed</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Fast (~5 cycles)</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Slower (~20-100 cycles)</p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Pattern</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>All wait, all proceed</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>One at a time</p>
  </td>
 </tr>
</table>

<p class=MsoNormal><b>MCQs:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Which operates on global memory? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) __syncthreads()</li>
  <li class=MsoNormal>b) atomicCAS() &#10003;</li>
  <li class=MsoNormal>c) Both</li>
  <li class=MsoNormal>d) Neither</li>
 </ul>
 <li class=MsoNormal>Which allows all threads to proceed simultaneously after
     synchronization? </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) atomicCAS()</li>
  <li class=MsoNormal>b) __syncthreads() &#10003;</li>
  <li class=MsoNormal>c) Both</li>
  <li class=MsoNormal>d) Neither</li>
 </ul>
 <li class=MsoNormal>For maximum performance in block-local operations, prefer:
     </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>a) atomicCAS()</li>
  <li class=MsoNormal>b) __syncthreads() &#10003;</li>
  <li class=MsoNormal>c) No synchronization</li>
  <li class=MsoNormal>d) CPU synchronization</li>
 </ul>
</ol>

<p class=MsoNormal><b>Use Cases:</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Choosing correct synchronization primitive</li>
 <li class=MsoNormal>Performance optimization</li>
 <li class=MsoNormal>Algorithm design decisions</li>
 <li class=MsoNormal>Debugging synchronization issues</li>
</ul>

<p class=MsoNormal><b>Numericals:</b> <b>Problem 1:</b> Cost comparison for
1024 threads cooperating:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Scenario A (block-local, __syncthreads())</b>: </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>10 barriers × 5 cycles = 50 cycles</li>
 </ul>
 <li class=MsoNormal><b>Scenario B (using atomicCAS() unnecessarily)</b>: </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal>1024 × 20 cycles = 20,480 cycles</li>
 </ul>
 <li class=MsoNormal><b>Ratio:</b> 410x slower!</li>
</ul>

<p class=MsoNormal><b>Problem 2:</b> Power consumption:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Busy-waiting with atomicCAS():</b> High power (spinning
     threads)</li>
 <li class=MsoNormal><b>__syncthreads():</b> Lower power (threads can sleep)</li>
 <li class=MsoNormal><b>Difference:</b> Can be 2-10x power savings</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Summary of Key Concepts:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>Critical sections</b> need protection from simultaneous
     access</li>
 <li class=MsoNormal><b>Dekker's Algorithm</b> shows evolution of
     synchronization (Versions 1-3 all have issues)</li>
 <li class=MsoNormal><b>Peterson's Algorithm</b> solves 2-process mutual
     exclusion correctly</li>
 <li class=MsoNormal><b>__syncthreads()</b> synchronizes threads within a block
     (barrier)</li>
 <li class=MsoNormal><b>atomicCAS()</b> provides device-wide mutual exclusion
     (lock)</li>
 <li class=MsoNormal>Choose the right tool: barriers for cooperation, atomics
     for protection</li>
</ol>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<div style='border:none;border-bottom:double windowtext 2.25pt;padding:0in 0in 1.0pt 0in'>

<p class=MsoNormal style='border:none;padding:0in'>&nbsp;</p>

</div>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Below is a <b>complete, slide-by-slide breakdown</b> of <b>GPU_Programming_Lect10.pdf</b>
in <b>simple language</b>, with:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Easy Explanation</b></li>
 <li class=MsoNormal><b>MCQs (4 options)</b></li>
 <li class=MsoNormal><b>Use Cases</b></li>
 <li class=MsoNormal><b>Numerical (where applicable)</b></li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>PAGE 1 – Title Slide</b></p>

<p class=MsoNormal><b>Easy Explanation</b></p>

<p class=MsoNormal>This is just the title of the lecture: <b>GPU Programming,
Lecture 10</b>. It tells us we are learning about parallel programming on GPUs,
focusing on <b>synchronization and critical sections</b>.</p>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>What is the topic of Lecture 10? a) CPU Scheduling b) GPU
     Synchronization c) File I/O d) Web Programming <b>Ans: b</b></li>
 <li class=MsoNormal>What does &quot;CS&quot; stand for in this lecture? a)
     Computer Science b) Critical Section c) CUDA Syntax d) Cache Storage <b>Ans:
     b</b></li>
</ol>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Starting a new lecture on GPU thread safety.</li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>N/A (title slide)</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>PAGE 2 – Critical Section</b></p>

<p class=MsoNormal><b>Easy Explanation</b></p>

<p class=MsoNormal>A <b>critical section</b> is a part of code where <b>only
one thread</b> should run at a time because it uses <b>shared data</b> (like a
global variable). If two threads run it together &#8594; <b>race condition</b>
&#8594; wrong result. Any solution must follow 3 rules:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>Mutual Exclusion</b>: Only one thread inside at a time.</li>
 <li class=MsoNormal><b>Progress</b>: Someone must be able to enter when
     needed.</li>
 <li class=MsoNormal><b>Bounded Waiting</b>: No thread waits forever.</li>
</ol>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>What happens if two threads enter a critical section at
     once? a) Faster execution b) Race condition c) Automatic sync d) No effect
     <b>Ans: b</b></li>
 <li class=MsoNormal>Which is NOT a requirement for critical section solution?
     a) Mutual Exclusion b) Progress c) Speed Priority d) Bounded Waiting <b>Ans:
     c</b></li>
</ol>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Updating a shared bank balance in a banking app.</li>
 <li class=MsoNormal>Modifying a global score in a game.</li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>N/A</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>PAGE 3 – Data Race Example</b></p>

<p class=MsoNormal><b>Easy Explanation</b></p>

<p class=MsoNormal>c</p>

<p class=MsoNormal>counter = counter + 1;</p>

<p class=MsoNormal>Looks simple, but if <b>two threads</b> run this at the same
time:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Both read counter = 0</li>
 <li class=MsoNormal>Both compute 0 + 1 = 1</li>
 <li class=MsoNormal>Both write 1 &#8594; Final result = <b>1 instead of 2</b>
     &#8594; <b>Data Race!</b></li>
</ol>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>In the example, final value of counter should be: a) 0 b)
     1 c) 2 d) 3 <b>Ans: c</b> (but race makes it <b>b</b>)</li>
 <li class=MsoNormal>What causes the wrong result? a) Compiler error b) No
     synchronization c) Wrong variable name d) Memory overflow <b>Ans: b</b></li>
</ol>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Counting visitors to a website.</li>
 <li class=MsoNormal>Incrementing score in multiplayer game.</li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<p class=MsoNormal><b>Q:</b> If 4 threads run counter++ without sync, and
counter starts at 0, what’s the <b>expected</b> vs <b>actual</b> result? <b>Expected:</b>
4 <b>Actual (possible):</b> 1, 2, 3, or 4 (race-dependent) <b>Correct with
sync:</b> Always 4</p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>PAGE 4 – Dekker’s Algorithm Version 1</b></p>

<p class=MsoNormal><b>Easy Explanation</b></p>

<p class=MsoNormal>Uses a <b>shared variable thread_no</b> to decide <b>whose
turn</b> it is.</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Thread 1 waits until thread_no == 1</li>
 <li class=MsoNormal>Thread 2 waits until thread_no == 2 After finishing, it <b>passes
     the turn</b> to the other.</li>
</ul>

<p class=MsoNormal>Like two people taking turns using a single bathroom.</p>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>What does Thread1 wait for in entry section? a) thread_no
     == 1 b) thread_no == 2 c) thread_no == 0 d) completed == true <b>Ans: a</b></li>
 <li class=MsoNormal>After CS, Thread1 sets thread_no to: a) 1 b) 2 c) 0 d) -1 <b>Ans:
     b</b></li>
</ol>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Two processes sharing a printer.</li>
 <li class=MsoNormal>Two robots using one charging station.</li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>N/A (algorithm logic)</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>PAGE 5 – Explanation (Dekker V1)</b></p>

<p class=MsoNormal><b>Easy Explanation</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>If thread_no = 1 &#8594; only <b>Thread1</b> can enter</li>
 <li class=MsoNormal>If thread_no = 2 &#8594; only <b>Thread2</b> can enter</li>
 <li class=MsoNormal>After exit, it <b>changes the number</b> so the other can
     go.</li>
</ul>

<p class=MsoNormal>Simple turn-based system.</p>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>In Case 1 (thread_no=1), who waits? a) Thread1 b) Thread2
     c) Both d) None <b>Ans: b</b></li>
</ol>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Two students sharing one microscope in lab.</li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>N/A</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>PAGE 6 – Step-by-step Execution</b></p>

<p class=MsoNormal><b>Easy Explanation</b></p>

<p class=MsoNormal>Shows timeline:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Thread1 enters (thread_no=1)</li>
 <li class=MsoNormal>Thread2 waits</li>
 <li class=MsoNormal>Thread1 exits &#8594; sets thread_no=2</li>
 <li class=MsoNormal>Thread2 enters</li>
 <li class=MsoNormal>Thread2 exits &#8594; sets thread_no=1 &#8594; Repeats</li>
</ol>

<p class=MsoNormal>Like a ping-pong game.</p>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>In step 3, what does Thread1 do? a) Waits b) Sets
     thread_no = 2 c) Enters CS again d) Ends <b>Ans: b</b></li>
</ol>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Two cashiers sharing one receipt printer.</li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>N/A</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>PAGE 7 – Dekker’s Algorithm Version 2</b></p>

<p class=MsoNormal><b>Easy Explanation</b></p>

<p class=MsoNormal>Now uses <b>two boolean flags</b>:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>th1 = true &#8594; Thread1 wants to enter</li>
 <li class=MsoNormal>th2 = true &#8594; Thread2 wants to enter</li>
</ul>

<p class=MsoNormal>Each thread:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Sets own flag = true</li>
 <li class=MsoNormal>Waits if other’s flag is true</li>
 <li class=MsoNormal>Enters CS</li>
 <li class=MsoNormal>Sets own flag = false</li>
</ol>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>What does th1 = true mean? a) Thread1 is done b) Thread1
     wants CS c) Thread2 is waiting d) Error <b>Ans: b</b></li>
 <li class=MsoNormal>Where is the while loop used? a) Entry section b) Critical
     section c) Exit section d) Remainder <b>Ans: a</b></li>
</ol>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Two apps trying to write to same log file.</li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>N/A</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>PAGE 8 – Explanation (Dekker V2)</b></p>

<p class=MsoNormal><b>Easy Explanation</b></p>

<p class=MsoNormal>Both threads <b>check each other’s flag</b> before entering.
But <b>problem</b>: if both set flag to true at same time &#8594; <b>deadlock</b>!
Both wait forever.</p>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>What is the main issue in Version 2? a) No mutual
     exclusion b) Possible deadlock c) Too slow d) Uses too much memory <b>Ans:
     b</b></li>
 <li class=MsoNormal>To enter CS, Thread1 needs: a) th2 == false b) th1 ==
     false c) th2 == true d) th1 == true <b>Ans: a</b></li>
</ol>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Shows why <b>simple flag check fails</b>.</li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>N/A</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>PAGE 9 – Dekker’s Algorithm Version 3</b></p>

<p class=MsoNormal><b>Easy Explanation</b></p>

<p class=MsoNormal><b>Fixes deadlock</b>: Now, thread <b>sets its flag FIRST</b>,
then checks the other.</p>

<p class=MsoNormal>c</p>

<p class=MsoNormal>th1wantstoenter = true;</p>

<p class=MsoNormal>while (th2wantstoenter == true);<i>  // wait</i></p>

<p class=MsoNormal>&#8594; One will see the other hasn't raised flag yet
&#8594; enters safely.</p>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>In V3, flag is set: a) After while loop b) Before while
     loop c) Inside CS d) Never <b>Ans: b</b></li>
</ol>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Improved version for two-thread sync.</li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>N/A</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>PAGE 10 – Explanation (Dekker V3)</b></p>

<p class=MsoNormal><b>Easy Explanation</b></p>

<p class=MsoNormal>Only <b>one thread</b> can have:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Its flag = true</li>
 <li class=MsoNormal>Other’s flag = false</li>
</ul>

<p class=MsoNormal>So no deadlock. Table shows safe progression.</p>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>In step 4, both flags true &#8594; who proceeds? a)
     Thread1 b) Thread2 c) None d) Both <b>Ans: c (deadlock avoided by order)</b></li>
</ol>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Two network nodes accessing shared channel.</li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>N/A</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>PAGE 11 – Peterson’s Algorithm</b></p>

<p class=MsoNormal><b>Easy Explanation</b></p>

<p class=MsoNormal>Best solution for <b>two threads</b>. Uses:</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>flag[2]: &quot;I want to enter&quot;</li>
 <li class=MsoNormal>turn: &quot;Whose turn to go&quot;</li>
</ul>

<p class=MsoNormal>Entry:</p>

<p class=MsoNormal>c</p>

<p class=MsoNormal>flag[i] = true;</p>

<p class=MsoNormal>turn = j;<i>  // give favor to other</i></p>

<p class=MsoNormal>while (flag[j] &amp;&amp; turn == j);<i>  // wait if other
wants and has turn</i></p>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>What does turn = 1 mean? a) Thread0 goes first b) Thread1
     goes first c) Error d) No one <b>Ans: b</b></li>
 <li class=MsoNormal>volatile is used because: a) Memory is shared b) Compiler
     might cache c) For speed d) Syntax error <b>Ans: b</b></li>
</ol>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Two cores sharing cache line.</li>
 <li class=MsoNormal>OS process scheduling.</li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>N/A</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>PAGE 12 – Explanation (Peterson)</b></p>

<p class=MsoNormal><b>Easy Explanation</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Flags</b> &#8594; show interest</li>
 <li class=MsoNormal><b>Turn</b> &#8594; breaks tie fairly &#8594; Satisfies <b>all
     3 conditions</b>:</li>
</ul>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Mutual Exclusion</li>
 <li class=MsoNormal>Progress</li>
 <li class=MsoNormal>Bounded Waiting (no starvation)</li>
</ol>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Which condition prevents starvation? a) Mutual Exclusion
     b) Progress c) Bounded Waiting d) Turn <b>Ans: c</b></li>
</ol>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Standard in OS textbooks for 2-process sync.</li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>N/A</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>PAGE 13 – __syncthreads() (Barrier)</b></p>

<p class=MsoNormal><b>Easy Explanation</b></p>

<p class=MsoNormal>__syncthreads() = <b>barrier</b> All threads in a <b>block</b>
must reach this line before <b>any</b> can continue. Used in <b>shared memory</b>
operations (like reduction).</p>

<p class=MsoNormal>Without it &#8594; some threads read old data.</p>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>__syncthreads() works across: a) All blocks b) One block
     only c) CPU and GPU d) Host code <b>Ans: b</b></li>
 <li class=MsoNormal>Used after: a) Loading data to shared mem b) Kernel launch
     c) Memory allocation d) printf <b>Ans: a</b></li>
</ol>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Parallel sum reduction</b> in a block</li>
 <li class=MsoNormal><b>Tiled matrix multiplication</b></li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<p class=MsoNormal><b>Q:</b> Block has 8 threads. How many must reach
__syncthreads() before proceeding? <b>Ans:</b> <b>All 8</b></p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>PAGE 14 – GPU Equivalent: atomicCAS</b></p>

<p class=MsoNormal><b>Easy Explanation</b></p>

<p class=MsoNormal>atomicCAS(lock, 0, 1) &#8594; <b>Compare and Swap</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>If lock == 0 &#8594; set to 1, return old value (0)</li>
 <li class=MsoNormal>Only <b>one thread</b> wins &#8594; enters critical
     section</li>
 <li class=MsoNormal>Others <b>spin-wait</b></li>
</ul>

<p class=MsoNormal>Works <b>across blocks</b> (global memory).</p>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>atomicCAS is used for: a) Block sync b) Global mutual
     exclusion c) Shared memory d) Host sync <b>Ans: b</b></li>
</ol>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Global counter update</li>
 <li class=MsoNormal>Building a lock for multiple blocks</li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>N/A</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>PAGE 15 – Visualization of __syncthreads()</b></p>

<p class=MsoNormal><b>Easy Explanation</b></p>

<p class=MsoNormal>All threads do <b>Work A</b> &#8594; hit barrier &#8594; <b>wait
(X)</b> &#8594; all arrive &#8594; do <b>Work B</b> Ensures <b>shared memory is
ready</b>.</p>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>What do &quot;X&quot; marks represent? a) Error b) Waiting
     at barrier c) Critical section d) Memory load <b>Ans: b</b></li>
</ol>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Ensuring all threads loaded tile before computation.</li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>N/A</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>PAGE 16 – Visualization of atomicCAS()</b></p>

<p class=MsoNormal><b>Easy Explanation</b></p>

<p class=MsoNormal>All threads try to grab lock &#8594; only <b>one wins</b>
&#8594; others <b>spin</b> &#8594; when lock released &#8594; next wins.</p>

<p class=MsoNormal>Like a <b>ticket system</b>.</p>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>How many threads enter CS at once with atomicCAS? a) All
     b) One c) Half d) None <b>Ans: b</b></li>
</ol>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Histogram update from multiple blocks</li>
 <li class=MsoNormal>Pushing to global queue</li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>N/A</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>PAGE 17 – Comparisons</b></p>

<p class=MsoNormal><b>Easy Explanation</b></p>

<table class=MsoNormalTable border=0 cellspacing=3 cellpadding=0>
 <thead>
  <tr>
   <td style='padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Use</b></p>
   </td>
   <td style='padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>__syncthreads()</b></p>
   </td>
   <td style='padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>atomicCAS()</b></p>
   </td>
  </tr>
 </thead>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Scope</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>One block</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>All blocks</p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Purpose</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Sync shared mem</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Global lock</p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Example</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Reduction</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Global counter</p>
  </td>
 </tr>
</table>

<p class=MsoNormal><b>MCQs</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Use __syncthreads() for: a) Global counter b) Tiled matrix
     mul c) File writing d) Host sync <b>Ans: b</b></li>
 <li class=MsoNormal>atomicCAS is needed when: a) Threads in same block b)
     Update global variable c) Load from shared mem d) Launch kernel <b>Ans: b</b></li>
</ol>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>__syncthreads() &#8594; <b>Parallel reduction, convolution</b></li>
 <li class=MsoNormal>atomicCAS &#8594; <b>Histogram, work queue</b></li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<p class=MsoNormal><b>Q:</b> 1024 threads, 4 blocks (256 threads each). How
many can use __syncthreads() together? <b>Ans:</b> Max <b>256 per block</b></p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>PAGE 18 – Blank/End</b></p>

<p class=MsoNormal><b>Easy Explanation</b></p>

<p class=MsoNormal>End of lecture.</p>

<p class=MsoNormal><b>MCQs / Use Cases / Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>N/A</li>
</ul>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Summary Table</b></p>

<table class=MsoNormalTable border=0 cellspacing=3 cellpadding=0>
 <thead>
  <tr>
   <td style='padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Page</b></p>
   </td>
   <td style='padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Topic</b></p>
   </td>
   <td style='padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>Key Idea</b></p>
   </td>
   <td style='padding:.75pt .75pt .75pt .75pt'>
   <p class=MsoNormal><b>GPU Tool</b></p>
   </td>
  </tr>
 </thead>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>2</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Critical Section</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>One thread at a time</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>—</p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>3</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Data Race</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>counter++ fails</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>—</p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>4–10</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Dekker’s</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Turn + flags</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Software</p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>11–12</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Peterson’s</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Best for 2 threads</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Software</p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>13</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>__syncthreads()</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Block barrier</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>CUDA</p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>14–16</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>atomicCAS</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Global lock</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>CUDA</p>
  </td>
 </tr>
 <tr>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>17</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Compare</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>Block vs Global</p>
  </td>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal>—</p>
  </td>
 </tr>
</table>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<p class=MsoNormal><b>Let me know if you want this in PDF/notes format or with
code examples!</b></p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<div style='border:none;border-bottom:double windowtext 2.25pt;padding:0in 0in 1.0pt 0in'>

<p class=MsoNormal style='border:none;padding:0in'>&nbsp;</p>

</div>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>The document &quot;GPU Programming Lecture-10&quot; covers
key concepts in GPU programming related to thread synchronization and mutual
exclusion. Below is a detailed explanation of each slide, followed by
multiple-choice questions (MCQs), use cases, and numerical problems where
applicable.</p>

<p class=MsoNormal><b>Critical Section</b></p>

<p class=MsoNormal>A&nbsp;critical section&nbsp;is a part of code where shared
resources like variables, files, or memory are accessed or modified. Only one
thread should execute this section at a time. If multiple threads enter it
simultaneously, a&nbsp;race condition&nbsp;occurs, leading to incorrect
results.<span style='font-family:"Arial",sans-serif'>&#8203;</span></p>

<p class=MsoNormal>For example, two threads trying to increment a shared
counter from 0 may both read 0, add 1, and write back 1, resulting in a final
value of 1 instead of 2.<span style='font-family:"Arial",sans-serif'>&#8203;</span></p>

<p class=MsoNormal><b>MCQs</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>What is a critical section?<br>
     a) A fast section of code<br>
     b) A code block accessing shared resources, allowing only one thread at a
     time<span style='font-family:"Arial",sans-serif'>&#8203;</span><br>
     c) A loop that runs forever<br>
     d) A function with no parameters</li>
 <li class=MsoNormal>What happens if two threads access a critical section at
     the same time?<br>
     a) The program speeds up<br>
     b) A race condition occurs<span style='font-family:"Arial",sans-serif'>&#8203;</span><br>
     c) The GPU shuts down<br>
     d) Nothing changes</li>
</ul>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Updating a shared counter in a parallel application</li>
 <li class=MsoNormal>Writing to a log file from multiple threads</li>
 <li class=MsoNormal>Modifying a global configuration variable<span
     style='font-family:"Arial",sans-serif'>&#8203;</span></li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>If 5 threads each increment a shared counter from 0, and
     no synchronization is used, what could be the final value?<br>
     Answer: Any value from 1 to 5, depending on interleaving.<span
     style='font-family:"Arial",sans-serif'>&#8203;</span></li>
</ul>

<p class=MsoNormal><b>Solution Requirements</b></p>

<p class=MsoNormal>A correct solution to the critical section problem must
satisfy three conditions:&nbsp;Mutual Exclusion,&nbsp;Progress, and&nbsp;Bounded
Waiting.<span style='font-family:"Arial",sans-serif'>&#8203;</span></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Mutual Exclusion: Only one thread can be in the critical
     section at a time.</li>
 <li class=MsoNormal>Progress: If no thread is in the critical section, a
     thread that wants to enter should not be blocked unnecessarily.</li>
 <li class=MsoNormal>Bounded Waiting: A thread waiting to enter the critical
     section must do so within a finite number of steps.<span style='font-family:
     "Arial",sans-serif'>&#8203;</span></li>
</ul>

<p class=MsoNormal><b>MCQs</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Which condition ensures only one thread enters the
     critical section?<br>
     a) Progress<br>
     b) Bounded Waiting<br>
     c) Mutual Exclusion<span style='font-family:"Arial",sans-serif'>&#8203;</span><br>
     d) Fairness</li>
 <li class=MsoNormal>What does bounded waiting prevent?<br>
     a) Deadlock<br>
     b) Starvation<span style='font-family:"Arial",sans-serif'>&#8203;</span><br>
     c) Race conditions<br>
     d) Infinite loops</li>
</ul>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Designing thread-safe libraries</li>
 <li class=MsoNormal>Implementing operating system kernels</li>
 <li class=MsoNormal>Building distributed systems with shared state<span
     style='font-family:"Arial",sans-serif'>&#8203;</span></li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>If a thread waits indefinitely to enter a critical
     section, which condition is violated?<br>
     Answer: Bounded Waiting.<span style='font-family:"Arial",sans-serif'>&#8203;</span></li>
</ul>

<p class=MsoNormal><b>Dekker’s Algorithm - Version 1</b></p>

<p class=MsoNormal>This algorithm uses a shared variable&nbsp;thread_no&nbsp;to
control access. Thread1 enters only if&nbsp;thread_no == 1, then sets it to 2
to allow Thread2. Similarly, Thread2 sets it back to 1 after exiting.<span
style='font-family:"Arial",sans-serif'>&#8203;</span></p>

<p class=MsoNormal>It ensures mutual exclusion but does not satisfy progress
because one thread may be forced to wait even when the other is not in the
critical section.<span style='font-family:"Arial",sans-serif'>&#8203;</span></p>

<p class=MsoNormal><b>MCQs</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>How does Dekker’s Algorithm Version 1 ensure mutual
     exclusion?<br>
     a) Using two flags<br>
     b) Using a turn variable<br>
     c) Using a shared&nbsp;thread_no&nbsp;variable<span style='font-family:
     "Arial",sans-serif'>&#8203;</span><br>
     d) Using atomic operations</li>
 <li class=MsoNormal>Why does Version 1 fail progress?<br>
     a) It uses too much memory<br>
     b) One thread may wait even when the other is not in CS<span
     style='font-family:"Arial",sans-serif'>&#8203;</span><br>
     c) It causes race conditions<br>
     d) It is too slow</li>
</ul>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Educational tool to understand mutual exclusion</li>
 <li class=MsoNormal>Basis for more advanced algorithms</li>
 <li class=MsoNormal>Simulating turn-based access in embedded systems<span
     style='font-family:"Arial",sans-serif'>&#8203;</span></li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>If Thread1 sets&nbsp;thread_no = 2&nbsp;and exits, what
     must Thread2 check to enter?<br>
     Answer:&nbsp;thread_no == 2.<span style='font-family:"Arial",sans-serif'>&#8203;</span></li>
</ul>

<p class=MsoNormal><b>Dekker’s Algorithm - Version 2</b></p>

<p class=MsoNormal>This version uses two flags:&nbsp;th1&nbsp;and&nbsp;th2.
Each thread sets its flag before entering and checks the other’s flag. However,
if both set their flags simultaneously, a&nbsp;deadlock&nbsp;occurs because
each waits for the other to clear its flag.<span style='font-family:"Arial",sans-serif'>&#8203;</span></p>

<p class=MsoNormal><b>MCQs</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>What causes deadlock in Version 2?<br>
     a) One thread crashes<br>
     b) Both threads set their flags at the same time<span style='font-family:
     "Arial",sans-serif'>&#8203;</span><br>
     c) The CPU overheats<br>
     d) Memory is full</li>
 <li class=MsoNormal>How do threads check for entry in Version 2?<br>
     a) By reading a global counter<br>
     b) By checking the other thread’s flag<span style='font-family:"Arial",sans-serif'>&#8203;</span><br>
     c) By using a timer<br>
     d) By sending a message</li>
</ul>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Teaching deadlock scenarios</li>
 <li class=MsoNormal>Demonstrating the need for tie-breaking mechanisms</li>
 <li class=MsoNormal>Analyzing software-based synchronization<span
     style='font-family:"Arial",sans-serif'>&#8203;</span></li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>If Thread1 sets&nbsp;th1 = true&nbsp;and Thread2
     sets&nbsp;th2 = true&nbsp;at the same time, what happens?<br>
     Answer: Deadlock — both wait forever.<span style='font-family:"Arial",sans-serif'>&#8203;</span></li>
</ul>

<p class=MsoNormal><b>Dekker’s Algorithm - Version 3</b></p>

<p class=MsoNormal>This version introduces&nbsp;th1wantstoenter&nbsp;and&nbsp;th2wantstoenter&nbsp;flags.
Threads signal intent before checking the other’s flag. However, it still
suffers from deadlock when both signal intent simultaneously.<span
style='font-family:"Arial",sans-serif'>&#8203;</span></p>

<p class=MsoNormal><b>MCQs</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>What is the main change in Version 3?<br>
     a) Uses atomic operations<br>
     b) Threads signal intent before waiting<span style='font-family:"Arial",sans-serif'>&#8203;</span><br>
     c) Adds a timer<br>
     d) Uses hardware locks</li>
 <li class=MsoNormal>What problem remains in Version 3?<br>
     a) Race condition<br>
     b) Deadlock<span style='font-family:"Arial",sans-serif'>&#8203;</span><br>
     c) Memory leak<br>
     d) Buffer overflow</li>
</ul>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Understanding intent-based synchronization</li>
 <li class=MsoNormal>Foundation for Peterson’s Algorithm</li>
 <li class=MsoNormal>Modeling turn-taking in robotics<span style='font-family:
     "Arial",sans-serif'>&#8203;</span></li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>If both threads set their &quot;want to enter&quot; flag
     to true, how many can enter the critical section?<br>
     Answer: 0 — deadlock occurs.<span style='font-family:"Arial",sans-serif'>&#8203;</span></li>
</ul>

<p class=MsoNormal><b>Peterson’s Algorithm</b></p>

<p class=MsoNormal>This algorithm combines flags and a&nbsp;turn&nbsp;variable.
Each thread sets its flag and gives turn to the other. It then waits if the
other wants to enter and it’s their turn. This ensures mutual exclusion,
progress, and bounded waiting.<span style='font-family:"Arial",sans-serif'>&#8203;</span></p>

<p class=MsoNormal><b>MCQs</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>What role does the&nbsp;turn&nbsp;variable play?<br>
     a) Measures execution time<br>
     b) Acts as a tie-breaker<span style='font-family:"Arial",sans-serif'>&#8203;</span><br>
     c) Counts thread ID<br>
     d) Stores result</li>
 <li class=MsoNormal>Which condition does Peterson’s Algorithm satisfy that
     Dekker’s does not?<br>
     a) Mutual Exclusion<br>
     b) Progress<span style='font-family:"Arial",sans-serif'>&#8203;</span><br>
     c) Speed<br>
     d) Simplicity</li>
</ul>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Implementing mutex in user-space</li>
 <li class=MsoNormal>Embedded systems with no hardware support</li>
 <li class=MsoNormal>Teaching advanced synchronization<span style='font-family:
     "Arial",sans-serif'>&#8203;</span></li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>If Thread0 sets&nbsp;flag=true,&nbsp;turn=1, and Thread1
     sets&nbsp;flag[1]=true,&nbsp;turn=0, who enters first?<br>
     Answer: Thread1, because&nbsp;turn=0&nbsp;and&nbsp;flag=true.<span
     style='font-family:"Arial",sans-serif'>&#8203;</span></li>
</ul>

<p class=MsoNormal><b>__syncthreads() Barrier</b></p>

<p class=MsoNormal>This CUDA function acts as a&nbsp;block-level barrier. All
threads in a block must reach it before any proceed. It ensures memory
consistency in shared memory, especially after loading data or during reduction
operations.<span style='font-family:"Arial",sans-serif'>&#8203;</span></p>

<p class=MsoNormal>Without it, threads might read stale data or overwrite
memory prematurely.<span style='font-family:"Arial",sans-serif'>&#8203;</span></p>

<p class=MsoNormal><b>MCQs</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>What does&nbsp;__syncthreads()&nbsp;ensure?<br>
     a) All threads in a block reach the point before proceeding<span
     style='font-family:"Arial",sans-serif'>&#8203;</span><br>
     b) Threads run faster<br>
     c) Memory is freed<br>
     d) Global variables are updated</li>
 <li class=MsoNormal>When should&nbsp;__syncthreads()&nbsp;be used?<br>
     a) After writing to shared memory<span style='font-family:"Arial",sans-serif'>&#8203;</span><br>
     b) Before launching a kernel<br>
     c) After kernel completion<br>
     d) When declaring variables</li>
</ul>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Tiled matrix multiplication</li>
 <li class=MsoNormal>Parallel reduction (e.g., sum, max)</li>
 <li class=MsoNormal>Histogram computation<span style='font-family:"Arial",sans-serif'>&#8203;</span></li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>In a block of 32 threads, if 31 have reached&nbsp;__syncthreads()&nbsp;and
     one is delayed, how many can proceed?<br>
     Answer: 0 — all must arrive.<span style='font-family:"Arial",sans-serif'>&#8203;</span></li>
</ul>

<p class=MsoNormal><b>Atomic Compare-and-Swap (atomicCAS)</b></p>

<p class=MsoNormal>This operation atomically checks if a memory location equals
an expected value and, if so, replaces it. It is used to implement locks in GPU
programming.<span style='font-family:"Arial",sans-serif'>&#8203;</span></p>

<p class=MsoNormal>The&nbsp;acquire_lock&nbsp;function uses&nbsp;atomicCAS&nbsp;to
set a lock from 0 to 1. Only one thread succeeds; others spin until the lock is
released using&nbsp;atomicExch.<span style='font-family:"Arial",sans-serif'>&#8203;</span></p>

<p class=MsoNormal><b>MCQs</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>What does&nbsp;atomicCAS(lock, 0, 1)&nbsp;do?<br>
     a) Adds 1 to lock<br>
     b) Sets lock to 1 only if it was 0<span style='font-family:"Arial",sans-serif'>&#8203;</span><br>
     c) Frees memory<br>
     d) Waits for signal</li>
 <li class=MsoNormal>How is the lock released?<br>
     a)&nbsp;atomicCAS(lock, 1, 0)<br>
     b)&nbsp;atomicExch(lock, 0)<span style='font-family:"Arial",sans-serif'>&#8203;</span><br>
     c)&nbsp;delete lock<br>
     d)&nbsp;lock = 0</li>
</ul>

<p class=MsoNormal><b>Use Cases</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Implementing global counters</li>
 <li class=MsoNormal>Thread-safe dynamic memory allocation on GPU</li>
 <li class=MsoNormal>Producer-consumer queues in CUDA<span style='font-family:
     "Arial",sans-serif'>&#8203;</span></li>
</ul>

<p class=MsoNormal><b>Numerical</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>If 100 threads call&nbsp;acquire_lock&nbsp;simultaneously,
     how many enter the critical section at once?<br>
     Answer: 1 — mutual exclusion.<span style='font-family:"Arial",sans-serif'>&#8203;</span></li>
</ul>

<p class=MsoNormal><b>Comparison of Synchronization Methods</b></p>

<table class=MsoNormalTable border=1 cellspacing=3 cellpadding=0 width=740
 style='width:555.0pt;border:solid windowtext 1.0pt'>
 <thead>
  <tr>
   <td valign=top style='border:solid windowtext 1.0pt;padding:6.0pt 6.0pt 6.0pt 6.0pt'>
   <p class=MsoNormal><b>Aspect</b></p>
   </td>
   <td valign=top style='border:solid windowtext 1.0pt;padding:6.0pt 6.0pt 6.0pt 6.0pt'>
   <p class=MsoNormal><b>__syncthreads()</b></p>
   </td>
   <td valign=top style='border:solid windowtext 1.0pt;padding:6.0pt 6.0pt 6.0pt 6.0pt'>
   <p class=MsoNormal><b>atomicCAS()</b></p>
   </td>
  </tr>
 </thead>
 <tr>
  <td valign=bottom style='border:solid windowtext 1.0pt;padding:6.85pt 6.0pt 6.85pt 6.0pt'>
  <p class=MsoNormal>Purpose</p>
  </td>
  <td valign=bottom style='border:solid windowtext 1.0pt;padding:6.85pt 6.0pt 6.85pt 6.0pt'>
  <p class=MsoNormal>Barrier synchronization&nbsp;<span style='font-family:
  "Arial",sans-serif'>&#8203;</span></p>
  </td>
  <td valign=bottom style='border:solid windowtext 1.0pt;padding:6.85pt 6.0pt 6.85pt 6.0pt'>
  <p class=MsoNormal>Mutual exclusion&nbsp;<span style='font-family:"Arial",sans-serif'>&#8203;</span></p>
  </td>
 </tr>
 <tr>
  <td valign=bottom style='border:solid windowtext 1.0pt;padding:6.85pt 6.0pt 6.85pt 6.0pt'>
  <p class=MsoNormal>Scope</p>
  </td>
  <td valign=bottom style='border:solid windowtext 1.0pt;padding:6.85pt 6.0pt 6.85pt 6.0pt'>
  <p class=MsoNormal>Within a block&nbsp;<span style='font-family:"Arial",sans-serif'>&#8203;</span></p>
  </td>
  <td valign=bottom style='border:solid windowtext 1.0pt;padding:6.85pt 6.0pt 6.85pt 6.0pt'>
  <p class=MsoNormal>Across blocks (global)&nbsp;<span style='font-family:"Arial",sans-serif'>&#8203;</span></p>
  </td>
 </tr>
 <tr>
  <td valign=bottom style='border:solid windowtext 1.0pt;padding:6.85pt 6.0pt 6.85pt 6.0pt'>
  <p class=MsoNormal>Waiting Threads</p>
  </td>
  <td valign=bottom style='border:solid windowtext 1.0pt;padding:6.85pt 6.0pt 6.85pt 6.0pt'>
  <p class=MsoNormal>All in block&nbsp;<span style='font-family:"Arial",sans-serif'>&#8203;</span></p>
  </td>
  <td valign=bottom style='border:solid windowtext 1.0pt;padding:6.85pt 6.0pt 6.85pt 6.0pt'>
  <p class=MsoNormal>Only contending threads&nbsp;<span style='font-family:
  "Arial",sans-serif'>&#8203;</span></p>
  </td>
 </tr>
 <tr>
  <td valign=bottom style='border:solid windowtext 1.0pt;padding:6.85pt 6.0pt 6.85pt 6.0pt'>
  <p class=MsoNormal>Use Case</p>
  </td>
  <td valign=bottom style='border:solid windowtext 1.0pt;padding:6.85pt 6.0pt 6.85pt 6.0pt'>
  <p class=MsoNormal>Shared memory coordination&nbsp;<span style='font-family:
  "Arial",sans-serif'>&#8203;</span></p>
  </td>
  <td valign=bottom style='border:solid windowtext 1.0pt;padding:6.85pt 6.0pt 6.85pt 6.0pt'>
  <p class=MsoNormal>Safe global memory access&nbsp;<span style='font-family:
  "Arial",sans-serif'>&#8203;</span></p>
  </td>
 </tr>
 <tr>
  <td valign=bottom style='border:solid windowtext 1.0pt;padding:6.85pt 6.0pt 6.85pt 6.0pt'>
  <p class=MsoNormal>Visual Metaphor</p>
  </td>
  <td valign=bottom style='border:solid windowtext 1.0pt;padding:6.85pt 6.0pt 6.85pt 6.0pt'>
  <p class=MsoNormal>&quot;Everyone stops at red light&quot;&nbsp;<span
  style='font-family:"Arial",sans-serif'>&#8203;</span></p>
  </td>
  <td valign=bottom style='border:solid windowtext 1.0pt;padding:6.85pt 6.0pt 6.85pt 6.0pt'>
  <p class=MsoNormal>&quot;One person uses restroom at a time&quot;&nbsp;<span
  style='font-family:"Arial",sans-serif'>&#8203;</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal>Use&nbsp;__syncthreads()&nbsp;for intra-block coordination
and&nbsp;atomicCAS()&nbsp;for inter-block or global data protection.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<div style='border:none;border-bottom:double windowtext 2.25pt;padding:0in 0in 1.0pt 0in'>

<p class=MsoNormal style='border:none;padding:0in'>&nbsp;</p>

</div>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal><b>Slide 1: Critical Section</b></p>

<p class=MsoNormal><b>Simple Language Explanation</b></p>

<p class=MsoNormal>Imagine a public restroom (a shared resource) that many
people (threads) want to use. However, only one person can use it at a time. In
programming, this restroom is called a <b>critical section</b>. It's a block of
code that accesses or modifies shared data (like a global variable). If
multiple people try to enter at the same time, things get messy (e.g., two
people trying to update the same ledger, leading to errors). This mess is
called a <b>race condition</b>.</p>

<p class=MsoNormal><b>MCQ</b></p>

<p class=MsoNormal><b>Question:</b> In multi-threaded programming, what is a
critical section? A. A function that can only be executed by one thread at a
time. B. A block of code that accesses a shared resource and should only be
executed by one thread at a time. C. The starting point where a thread begins
its execution. D. A waiting area where threads go after finishing their tasks.</p>

<p class=MsoNormal><b>Answer:</b> B</p>

<p class=MsoNormal><b>Use Cases</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>Bank Transfers:</b> Two threads simultaneously
     transferring money from the same account. The entire debit-credit
     operation must be treated as a single critical section to prevent money
     from being lost.</li>
 <li class=MsoNormal><b>E-commerce Inventory:</b> Multiple users buying the
     last item in stock simultaneously. The system must ensure only one user
     successfully decrements the stock count to prevent overselling.</li>
 <li class=MsoNormal><b>Game State Updates:</b> In a video game, multiple
     threads might update a player's score or health. This update must be
     atomic to prevent incorrect calculations.</li>
</ol>

<p class=MsoNormal><b>Numerical Problem</b></p>

<p class=MsoNormal><b>Question:</b> Assume a shared variable <b>balance = 100</b>.
Thread A and Thread B both want to execute <b>balance = balance - 50</b>.
Describe a sequence of execution that could lead to a race condition and state
the final incorrect result.</p>

<p class=MsoNormal><b>Answer:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Thread A reads the value of <b>balance</b>, which is <b>100</b>.</li>
 <li class=MsoNormal>The operating system switches to Thread B.</li>
 <li class=MsoNormal>Thread B also reads the value of <b>balance</b>, which is
     still <b>100</b>.</li>
 <li class=MsoNormal>Thread B calculates <b>100 - 50 = 50</b> and writes <b>50</b>
     back to <b>balance</b>. The balance is now <b>50</b>.</li>
 <li class=MsoNormal>The operating system switches back to Thread A.</li>
 <li class=MsoNormal>Thread A (which had read the value <b>100</b>) calculates <b>100
     - 50 = 50</b> and writes <b>50</b> back to <b>balance</b>. <b>Final
     Result:</b> The value of <b>balance</b> is <b>50</b>. <b>Correct Result
     Should Be:</b> <b>100 - 50 - 50 = 0</b>. Due to the race condition, a
     withdrawal was lost.</li>
</ol>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=0 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 2: The solution to critical section problem...</b></p>

<p class=MsoNormal><b>Simple Language Explanation</b></p>

<p class=MsoNormal>To solve the &quot;restroom&quot; problem (the critical
section problem), we need a good set of rules that must satisfy three
conditions:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>Mutual Exclusion:</b> Only one person in the restroom
     at a time. This is the most basic requirement.</li>
 <li class=MsoNormal><b>Progress:</b> If the restroom is empty and someone is
     waiting, the waiting person should be able to get in without unnecessary
     delay. The system shouldn't stall if no one is inside.</li>
 <li class=MsoNormal><b>Bounded Waiting:</b> No one should be forced to wait
     forever. There must be a limit on how long a person has to wait, ensuring
     everyone gets a fair chance.</li>
</ol>

<p class=MsoNormal><b>MCQ</b></p>

<p class=MsoNormal><b>Question:</b> The &quot;Bounded Waiting&quot; principle
ensures that: A. Only one thread can enter the critical section at a time. B.
If no thread is in the critical section, a thread that wants to enter must be
able to do so immediately. C. A thread's waiting time to enter the critical
section is finite; it will eventually get its turn. D. Threads can run
indefinitely outside the critical section.</p>

<p class=MsoNormal><b>Answer:</b> C</p>

<p class=MsoNormal><b>Use Cases</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>Operating System Schedulers:</b> The OS's process
     scheduling algorithms must adhere to these three principles to ensure
     multiple processes can use CPU resources fairly and efficiently without
     causing deadlocks or starvation.</li>
 <li class=MsoNormal><b>Database Locking Mechanisms:</b> Database Management
     Systems (like MySQL, PostgreSQL) use row or table locks to ensure that
     multiple transactions (treated as threads) follow these rules when
     modifying data, guaranteeing data consistency and integrity.</li>
</ol>

<p class=MsoNormal><b>Numerical Problem</b></p>

<p class=MsoNormal><b>Question:</b> A system has two threads, T1 and T2. The
system's rule is: T2 can only run <i>after</i> T1 has completed a full cycle,
and then T1 runs again, and so on. If T1 continuously needs to run and T2 also
wants to run, which principle is this system violating?</p>

<p class=MsoNormal><b>Answer:</b> This system violates the <b>Bounded Waiting</b>
principle. If T1 continuously requests and enters the critical section, T2
might be forced to wait indefinitely, never getting a chance to enter. Its
waiting time is not finite.</p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=0 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 3: Data Race Example</b></p>

<p class=MsoNormal><b>Simple Language Explanation</b></p>

<p class=MsoNormal>This slide uses a concrete example to show a race condition.
Imagine a counter <b>counter = 0</b>. Two threads both want to increment it. <b>Ideal
Scenario:</b> Thread 1 increments it to 1, then Thread 2 increments it to 2. <b>Race
Condition Scenario:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Thread 1 copies the value of <b>counter</b> (which is 0)
     to its own private workspace.</li>
 <li class=MsoNormal>Thread 2 also copies the value of <b>counter</b> (still 0)
     to its private workspace.</li>
 <li class=MsoNormal>Thread 1 calculates <b>0 + 1 = 1</b> and writes the result
     <b>1</b> back to <b>counter</b>.</li>
 <li class=MsoNormal>Thread 2 calculates <b>0 + 1 = 1</b> and writes the result
     <b>1</b> back to <b>counter</b>. The final value of <b>counter</b> is 1,
     not the expected 2. This happened because the threads didn't coordinate
     while accessing the shared variable.</li>
</ol>

<p class=MsoNormal><b>MCQ</b></p>

<p class=MsoNormal><b>Question:</b> In the <b>counter</b> example on the slide,
why is the final result 1 instead of 2? A. Because one of the threads failed to
execute. B. Because both threads read the same old value before the other could
write the new value. C. Because the operation <b>counter = counter + 1</b> is
syntactically incorrect. D. Because the threads were executing too fast.</p>

<p class=MsoNormal><b>Answer:</b> B</p>

<p class=MsoNormal><b>Use Cases</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>Website Like Counts:</b> If an article has 100 likes,
     and two users click the &quot;like&quot; button simultaneously. Without
     proper synchronization, the backend might only register 101 likes instead
     of 102.</li>
 <li class=MsoNormal><b>Counting File Lines:</b> Multiple threads read
     different parts of a large file to count lines, then add their individual
     counts to a global counter. If not synchronized, the final total count
     might be less than the actual number of lines.</li>
</ol>

<p class=MsoNormal><b>Numerical Problem</b></p>

<p class=MsoNormal><b>Question:</b> Assume <b>counter</b> starts at <b>10</b>.
Thread A executes <b>counter = counter + 5</b> and Thread B executes <b>counter
= counter + 10</b>. Describe a sequence of execution that could lead to a race
condition and state the final incorrect result.</p>

<p class=MsoNormal><b>Answer:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Thread A reads the value of <b>counter</b>, which is <b>10</b>.</li>
 <li class=MsoNormal>Thread B also reads the value of <b>counter</b>, which is <b>10</b>.</li>
 <li class=MsoNormal>Thread A calculates <b>10 + 5 = 15</b> and writes <b>15</b>
     back to <b>counter</b>.</li>
 <li class=MsoNormal>Thread B calculates <b>10 + 10 = 20</b> and writes <b>20</b>
     back to <b>counter</b>. <b>Final Result:</b> The value of <b>counter</b>
     is <b>20</b>. <b>Correct Result Should Be:</b> <b>10 + 5 + 10 = 25</b>.
     Thread A's operation was overwritten by Thread B's result.</li>
</ol>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=0 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slides 4 &amp; 5: Dekker’s Algorithm-Version 1</b></p>

<p class=MsoNormal><b>Simple Language Explanation</b></p>

<p class=MsoNormal>This is one of the first software solutions, like two people
taking turns using a resource. There is a shared sign <b>thread_no</b> that
says either &quot;Turn for 1&quot; or &quot;Turn for 2&quot;.</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Thread 1:</b> It keeps looking at the sign until it
     says &quot;Turn for 1&quot;. After it's done, it flips the sign to
     &quot;Turn for 2&quot;.</li>
 <li class=MsoNormal><b>Thread 2:</b> It keeps looking at the sign until it
     says &quot;Turn for 2&quot;. After it's done, it flips the sign to
     &quot;Turn for 1&quot;. This way, by using a &quot;pass&quot; (the <b>thread_no</b>
     variable), they ensure only one person is working at a time.</li>
</ul>

<p class=MsoNormal><b>MCQ</b></p>

<p class=MsoNormal><b>Question:</b> In Dekker's Algorithm Version 1, what is
the main purpose of the <b>thread_no</b> variable? A. To record which thread is
faster. B. To act as a &quot;pass&quot; that grants a thread the right to enter
the critical section. C. To count how many times a thread has entered the
critical section. D. To terminate the thread's loop.</p>

<p class=MsoNormal><b>Answer:</b> B</p>

<p class=MsoNormal><b>Use Cases</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>Dual-Core Processor Communication:</b> In a simple
     dual-core embedded system where two cores need to strictly alternate
     access to a shared hardware device (like a printer port), this simple
     turn-taking mechanism could be used.</li>
 <li class=MsoNormal><b>Ping-Pong Buffers:</b> In audio/video processing, one
     thread writes data to buffer A while another reads from it. When done,
     they switch roles, writing to/reading from buffer B. This handoff can be
     coordinated with a similar turn-taking idea.</li>
</ol>

<p class=MsoNormal><b>Numerical Problem</b></p>

<p class=MsoNormal><b>Question:</b> Assume <b>thread_no</b> is initially <b>1</b>.
Describe the state changes of Thread 1 and Thread 2 in the following sequence:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Thread 2 starts running.</li>
 <li class=MsoNormal>Thread 1 starts running.</li>
 <li class=MsoNormal>Thread 1 finishes its critical section.</li>
 <li class=MsoNormal>Thread 2 finishes its critical section.</li>
</ol>

<p class=MsoNormal><b>Answer:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>Thread 2 starts:</b> It checks <b>while(thread_no == 1)</b>.
     The condition is true, so it waits (spins) at this point.</li>
 <li class=MsoNormal><b>Thread 1 starts:</b> It checks <b>while(thread_no == 2)</b>.
     The condition is false, so it enters the critical section.</li>
 <li class=MsoNormal><b>Thread 1 finishes:</b> It executes <b>thread_no = 2</b>.
     Now, the waiting Thread 2's <b>while</b> loop condition becomes false, and
     Thread 2 can enter the critical section.</li>
 <li class=MsoNormal><b>Thread 2 finishes:</b> It executes <b>thread_no = 1</b>,
     giving the turn back to Thread 1.</li>
</ol>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=0 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slides 7 &amp; 8: Dekker’s Algorithm-Version 2</b></p>

<p class=MsoNormal><b>Simple Language Explanation</b></p>

<p class=MsoNormal>This version uses two &quot;status&quot; flags, <b>th1</b>
and <b>th2</b>, instead of a turn-taking sign.</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Each person (thread) checks the other's status before
     entering the &quot;restroom&quot; (critical section).</li>
 <li class=MsoNormal><b>Thread 1:</b> It keeps watching <b>th2</b>. If <b>th2</b>
     is <b>true</b> (meaning Thread 2 is inside or wants to enter), Thread 1
     waits. Otherwise, it sets its own flag <b>th1</b> to <b>true</b> and
     enters. When it leaves, it sets <b>th1</b> back to <b>false</b>.</li>
 <li class=MsoNormal><b>Thread 2:</b> Does the same, but watches <b>th1</b>. <b>The
     Problem:</b> If both people decide to enter at the exact same moment, they
     both set their flags to <b>true</b> and then both check the other's flag.
     Seeing that the other is <b>true</b>, they both wait forever. This is
     called <b>deadlock</b>.</li>
</ul>

<p class=MsoNormal><b>MCQ</b></p>

<p class=MsoNormal><b>Question:</b> What is the major problem with Dekker's
Algorithm Version 2? A. It violates the mutual exclusion principle. B. It can
lead to a deadlock. C. It is too inefficient. D. It doesn't work for two
threads.</p>

<p class=MsoNormal><b>Answer:</b> B</p>

<p class=MsoNormal><b>Use Cases</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>Educational Case Study:</b> The algorithm itself is
     flawed, so its primary use is as a classic &quot;what not to do&quot;
     example to teach how deadlocks can occur and why designing synchronization
     algorithms requires extreme care.</li>
 <li class=MsoNormal><b>Early Concurrency Research:</b> In the early days of
     computer science, such algorithms were important steps in exploring how to
     solve concurrency problems with pure software, inspiring later, more
     robust algorithms.</li>
</ol>

<p class=MsoNormal><b>Numerical Problem</b></p>

<p class=MsoNormal><b>Question:</b> Describe the exact sequence of steps that
would lead to a deadlock in Dekker's Algorithm Version 2.</p>

<p class=MsoNormal><b>Answer:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>Initial State:</b> <b>th1 = false</b>, <b>th2 = false</b>.</li>
 <li class=MsoNormal><b>Step 1:</b> Thread 1 executes <b>while(th2 == true);</b>.
     The condition is false, so it passes.</li>
 <li class=MsoNormal><b>Step 2:</b> The OS switches to Thread 2.</li>
 <li class=MsoNormal><b>Step 3:</b> Thread 2 executes <b>while(th1 == true);</b>.
     The condition is false, so it passes.</li>
 <li class=MsoNormal><b>Step 4:</b> Thread 1 executes <b>th1 = true;</b>.</li>
 <li class=MsoNormal><b>Step 5:</b> Thread 2 executes <b>th2 = true;</b>.</li>
 <li class=MsoNormal><b>Step 6:</b> Thread 1 goes back to the top of its loop
     and executes <b>while(th2 == true);</b>. Since <b>th2</b> is now <b>true</b>,
     Thread 1 waits indefinitely.</li>
 <li class=MsoNormal><b>Step 7:</b> Thread 2 goes back to the top of its loop
     and executes <b>while(th1 == true);</b>. Since <b>th1</b> is now <b>true</b>,
     Thread 2 also waits indefinitely. <b>Result:</b> Both threads are stuck
     waiting for each other—a deadlock has occurred.</li>
</ol>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=0 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slides 9 &amp; 10: Dekker’s Algorithm-Version 3</b></p>

<p class=MsoNormal><b>Simple Language Explanation</b></p>

<p class=MsoNormal>This version tries to fix the deadlock in Version 2. The
rule changes: &quot;raise your hand&quot; to show intent <i>before</i> checking
if others also want to enter.</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Thread 1:</b> First, it sets its flag <b>th1wantstoenter</b>
     to <b>true</b> (raises its hand). Then, it starts checking <b>th2wantstoenter</b>.
     If Thread 2 also wants to enter (<b>true</b>), Thread 1 waits.</li>
 <li class=MsoNormal><b>Thread 2:</b> Does the same. This change fixes the
     problem of setting flags simultaneously, but the code shown in the slide
     is incomplete and can still lead to deadlock (if both threads raise their
     hands and check each other at the same time). The full Dekker's algorithm
     is more complex, combining &quot;intent flags&quot; and a &quot;turn&quot;
     mechanism.</li>
</ul>

<p class=MsoNormal><b>MCQ</b></p>

<p class=MsoNormal><b>Question:</b> Compared to Version 2, what is the key
change in the order of operations in Dekker's Algorithm Version 3 before
entering the critical section? A. It checks the other's flag first, then sets
its own. B. It sets its own flag first, then checks the other's. C. It no
longer uses flags, but a single shared variable. D. It introduces a random wait
time.</p>

<p class=MsoNormal><b>Answer:</b> B</p>

<p class=MsoNormal><b>Use Cases</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>Teaching Algorithm Evolution:</b> It shows how
     modifying the order of operations can attempt to solve concurrency
     problems. It serves as a transition from the flawed Version 2 to the more
     complete Peterson's algorithm.</li>
 <li class=MsoNormal><b>&quot;Declare Intent, Then Check&quot; Pattern:</b>
     This pattern of &quot;first declare your intent, then check others'
     status&quot; is a foundation for many concurrency algorithms, even though
     this specific implementation is incomplete.</li>
</ol>

<p class=MsoNormal><b>Numerical Problem</b></p>

<p class=MsoNormal><b>Question:</b> Assume <b>th1wantstoenter</b> and <b>th2wantstoenter</b>
are initially <b>false</b>. Describe the following execution sequence:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Thread 1 executes <b>th1wantstoenter = true;</b>.</li>
 <li class=MsoNormal>Thread 2 executes <b>th2wantstoenter = true;</b>.</li>
 <li class=MsoNormal>What happens next in the <b>while</b> loops of Thread 1
     and Thread 2?</li>
</ol>

<p class=MsoNormal><b>Answer:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Thread 1 executes <b>th1wantstoenter = true;</b>.</li>
 <li class=MsoNormal>Thread 2 executes <b>th2wantstoenter = true;</b>.</li>
 <li class=MsoNormal>Thread 1 executes <b>while(th2wantstoenter == true);</b>.
     Since <b>th2wantstoenter</b> is <b>true</b>, Thread 1 enters a waiting
     state.</li>
 <li class=MsoNormal>Thread 2 executes <b>while(th1wantstoenter == true);</b>.
     Since <b>th1wantstoenter</b> is <b>true</b>, Thread 2 also enters a
     waiting state. <b>Result:</b> As the slide hints, this incomplete version
     still leads to a deadlock.</li>
</ol>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=0 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slides 11 &amp; 12: Peterson's Algorithm</b></p>

<p class=MsoNormal><b>Simple Language Explanation</b></p>

<p class=MsoNormal>Peterson's algorithm is the perfect upgrade to Dekker's
algorithm, and it's very clever. It combines the &quot;intent flags&quot; and
the &quot;turn-taking&quot; mechanisms. Imagine two people, A and B:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>Declare Intent:</b> A wants to enter, so it raises its
     flag <b>flag[A]</b> (<b>true</b>). B does the same.</li>
 <li class=MsoNormal><b>Yield Priority:</b> As A raises its flag, it also gives
     a &quot;priority token&quot; <b>turn</b> to B, saying &quot;You go first
     this time.&quot;</li>
 <li class=MsoNormal><b>Final Check:</b> A makes a final check at the door:
     &quot;If B hasn't raised its flag (<b>flag[B]</b> is <b>false</b>), OR I
     gave the token to B (<b>turn</b> is B), then I'll enter.&quot; <b>Why it
     works:</b></li>
</ol>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>If only A wants to enter, A enters.</li>
 <li class=MsoNormal>If both want to enter simultaneously, A gives the token to
     B, and B gives it to A. But in the final check, whoever's assignment to <b>turn</b>
     happened last determines the outcome. If A's <b>turn = 1</b> was last,
     then <b>turn</b> is 1. A's condition (<b>turn == 1</b>) is true, so A
     enters. B's condition is false, so B waits. This breaks the tie and
     prevents deadlock.</li>
</ul>

<p class=MsoNormal><b>MCQ</b></p>

<p class=MsoNormal><b>Question:</b> In Peterson's algorithm, what is the main
purpose of the <b>turn</b> variable? A. To record which thread entered the
critical section last. B. To act as an &quot;intent flag&quot; to signal a
thread's desire to enter. C. To act as a &quot;tie-breaker&quot; to resolve the
situation when both threads want to enter at the same time. D. To calculate how
long a thread has been waiting.</p>

<p class=MsoNormal><b>Answer:</b> C</p>

<p class=MsoNormal><b>Use Cases</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>Operating System Kernels:</b> In some simple or
     educational OS kernels, Peterson's algorithm can be used to implement a
     mutex (mutual exclusion lock) between two processes because it's a pure
     software solution that doesn't require special hardware support.</li>
 <li class=MsoNormal><b>Foundation for Concurrency:</b> It's a fundamental
     concept for understanding more complex locking mechanisms (like mutexes
     and semaphores). Nearly every student learning concurrent programming will
     encounter it.</li>
</ol>

<p class=MsoNormal><b>Numerical Problem</b></p>

<p class=MsoNormal><b>Question:</b> There are two processes, Process 0 and
Process 1. <b>turn</b> is initially any value (e.g., 0), and <b>flag[0]</b> and
<b>flag[1]</b> are initially <b>false</b>. Describe how Peterson's algorithm
ensures only one can succeed when both threads want to enter the critical
section at nearly the same time.</p>

<p class=MsoNormal><b>Answer:</b> Assume Process 0 and Process 1 execute
concurrently:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Process 0 executes <b>flag[0] = true;</b>.</li>
 <li class=MsoNormal>Process 1 executes <b>flag[1] = true;</b>.</li>
 <li class=MsoNormal>Process 0 executes <b>turn = 1;</b> (gives priority to 1).</li>
 <li class=MsoNormal>Process 1 executes <b>turn = 0;</b> (gives priority to 0).
     Assume the CPU executes in the order 1-&gt;2-&gt;3-&gt;4, so the final
     value of <b>turn</b> is <b>0</b>.</li>
 <li class=MsoNormal>Process 0 enters its <b>while</b> loop check: <b>while
     (flag[1] &amp;&amp; turn == 1)</b>. <b>flag[1]</b> is <b>true</b>, but <b>turn</b>
     is <b>0</b>, so the condition is false. <b>Process 0 enters the critical
     section.</b></li>
 <li class=MsoNormal>Process 1 enters its <b>while</b> loop check: <b>while
     (flag[0] &amp;&amp; turn == 0)</b>. <b>flag[0]</b> is <b>true</b> and <b>turn</b>
     is also <b>0</b>, so the condition is true. <b>Process 1 waits here.</b>
     This guarantees that only Process 0 enters, avoiding deadlock and
     conflict.</li>
</ol>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=0 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 13: __syncthreads() (barrier)</b></p>

<p class=MsoNormal><b>Simple Language Explanation</b></p>

<p class=MsoNormal><b>__syncthreads()</b> is a &quot;rendezvous point&quot; or
&quot;barrier&quot; in CUDA programming. Imagine a tour group (a thread block).
The tour guide (<b>__syncthreads()</b>) says: &quot;Everyone meet at the
entrance to this attraction. We will not go to the next attraction until <i>everyone</i>
has arrived.&quot;</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal>Within a GPU, threads in a block can execute at different
     speeds.</li>
 <li class=MsoNormal>When a thread hits <b>__syncthreads()</b>, it stops and
     waits.</li>
 <li class=MsoNormal>It waits until <i>all</i> threads in that block have
     reached this point. Only then are they all woken up to continue executing
     the code that follows. This is mainly used to ensure that all threads have
     finished their reads/writes to <b>shared memory</b> before the next step
     begins.</li>
</ul>

<p class=MsoNormal><b>MCQ</b></p>

<p class=MsoNormal><b>Question:</b> In CUDA, what is the primary function of <b>__syncthreads()</b>?
A. To terminate the entire kernel. B. To synchronize all threads in a grid. C.
To force all threads within a thread block to wait until they have all reached
that point. D. To release the GPU's shared memory.</p>

<p class=MsoNormal><b>Answer:</b> C</p>

<p class=MsoNormal><b>Use Cases</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>Parallel Reduction Sum:</b> As in the slide's example.
     First, all threads load data from global memory into shared memory. You
     must use <b>__syncthreads()</b> to ensure all data is loaded. Second,
     threads start pairing up and adding in shared memory. After each addition
     step, you need <b>__syncthreads()</b> to ensure all additions in that step
     are complete before the next step starts.</li>
 <li class=MsoNormal><b>Tiled Matrix Multiplication:</b> When calculating the
     product of a matrix tile, all threads work together to load sub-tiles of
     the matrices from global memory into shared memory. You must use <b>__syncthreads()</b>
     to wait until all tile data is loaded before any thread can start reading
     from shared memory to perform calculations.</li>
</ol>

<p class=MsoNormal><b>Numerical Problem</b></p>

<p class=MsoNormal><b>Question:</b> A thread block has 4 threads (T0, T1, T2,
T3). They execute the following code:</p>

<p class=MsoNormal>c</p>

<p class=MsoNormal>Line Wrapping</p>

<p class=MsoNormal>Collapse</p>

<p class=MsoNormal>Copy</p>

<p class=MsoNormal>1</p>

<p class=MsoNormal>2</p>

<p class=MsoNormal>3</p>

<p class=MsoNormal>4</p>

<p class=MsoNormal>5</p>

<p class=MsoNormal>6</p>

<p class=MsoNormal>7</p>

<p class=MsoNormal><span style='font-family:"Cambria Math",serif'>&#8964;</span></p>

<p class=MsoNormal>// shared memory array s_data[]</p>

<p class=MsoNormal>__global__ void myKernel() {</p>

<p class=MsoNormal>int tid = threadIdx.x;</p>

<p class=MsoNormal>s_data[tid] = tid * 2; // Step 1</p>

<p class=MsoNormal>__syncthreads(); // Barrier</p>

<p class=MsoNormal>s_data[tid] = s_data[tid] + 10; // Step 2</p>

<p class=MsoNormal>}</p>

<p class=MsoNormal>Assume T0 and T1 are very fast, and T2 and T3 are very slow.
Describe the effect of <b>__syncthreads()</b>.</p>

<p class=MsoNormal><b>Answer:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>Step 1:</b> T0 and T1 quickly execute <b>s_data[0]=0;</b>
     and <b>s_data[1]=2;</b>. They then hit <b>__syncthreads()</b> and
     immediately stop to wait.</li>
 <li class=MsoNormal>T2 and T3 are still executing <b>s_data[2]=4;</b> and <b>s_data[3]=6;</b>.</li>
 <li class=MsoNormal>Once T2 and T3 also finish Step 1 and reach <b>__syncthreads()</b>,
     all 4 threads have arrived.</li>
 <li class=MsoNormal>At this moment, the <b>__syncthreads()</b> barrier is
     lifted, and all 4 threads (T0, T1, T2, T3) simultaneously begin executing
     Step 2. <b>Effect:</b> <b>__syncthreads()</b> ensures that no thread
     starts Step 2 before all threads have completed Step 1. This guarantees
     that when T0 reads <b>s_data[0]</b> in Step 2, its value is the <b>0</b>
     written in Step 1, not some uninitialized value.</li>
</ol>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=0 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slide 14: GPU Equivalent of Dekker’s Algorithm: Atomic
Compare-and-Swap</b></p>

<p class=MsoNormal><b>Simple Language Explanation</b></p>

<p class=MsoNormal><b>atomicCAS</b> (Compare-And-Swap) is a hardware-level
&quot;atomic operation&quot; provided by the GPU, representing the modern,
efficient implementation of Dekker's algorithm's idea. Imagine a locker (a
memory address) with a lock.</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>The Operation:</b> <b>atomicCAS(address, expected,
     new_value)</b> means: &quot;Go to <b>address</b>. If the value there is <b>expected</b>,
     change it to <b>new_value</b> and tell me I succeeded. If it's not <b>expected</b>,
     do nothing and tell me I failed.&quot;</li>
 <li class=MsoNormal><b>The Key:</b> This entire &quot;read-compare-write&quot;
     sequence is <b>indivisible</b> (atomic). No other thread can interrupt it.</li>
 <li class=MsoNormal><b>How to Build a Lock:</b> Use a global variable <b>lock</b>
     (initially 0, meaning &quot;unlocked&quot;). A thread that wants to enter
     the critical section executes <b>atomicCAS(&amp;lock, 0, 1)</b>. Only one
     thread will successfully change the 0 to a 1 (acquire the lock). All other
     threads will fail and then continuously retry (spin-wait) until the thread
     that has the lock finishes and sets <b>lock</b> back to 0.</li>
</ul>

<p class=MsoNormal><b>MCQ</b></p>

<p class=MsoNormal><b>Question:</b> Why can the <b>atomicCAS</b> function be
used to implement a lock? A. Because it is faster than a normal variable
assignment. B. Because its &quot;read-compare-write&quot; operation is atomic
and cannot be interrupted by other threads. C. Because it automatically puts
failing threads to sleep. D. Because it can only be used on a GPU.</p>

<p class=MsoNormal><b>Answer:</b> B</p>

<p class=MsoNormal><b>Use Cases</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>Implementing a Global Mutex:</b> When multiple thread
     blocks need to access the same global resource (like the head pointer of a
     linked list), you can use <b>atomicCAS</b> to implement a global lock to
     protect that resource.</li>
 <li class=MsoNormal><b>Lock-Free Data Structures:</b> Used to implement
     complex lock-free queues, stacks, etc. For example, when adding a new node
     to the tail of a queue, <b>atomicCAS</b> can be used to atomically update
     the tail pointer.</li>
 <li class=MsoNormal><b>Global Counters:</b> While there's a dedicated <b>atomicAdd</b>,
     <b>atomicCAS</b> is a more general-purpose tool that can be used to build
     your own atomic addition (via a retry loop).</li>
</ol>

<p class=MsoNormal><b>Numerical Problem</b></p>

<p class=MsoNormal><b>Question:</b> There is a global memory variable <b>int
lock = 0;</b>. Thread A and Thread B both want to enter the critical section
and execute <b>atomicCAS(&amp;lock, 0, 1)</b>. Describe the possible outcomes.</p>

<p class=MsoNormal><b>Answer:</b> Assume Thread A's <b>atomicCAS</b> operation
is handled by the hardware first:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Thread A's <b>atomicCAS</b> checks the value of <b>lock</b>.
     It finds <b>0</b> (which matches the expected value).</li>
 <li class=MsoNormal>Thread A changes the value of <b>lock</b> to <b>1</b>.</li>
 <li class=MsoNormal>Thread A's <b>atomicCAS</b> returns success, and Thread A
     enters the critical section.</li>
 <li class=MsoNormal>Shortly after, Thread B's <b>atomicCAS</b> operation is
     handled. It checks the value of <b>lock</b> and finds <b>1</b> (which does
     not match the expected value <b>0</b>).</li>
 <li class=MsoNormal>Thread B's <b>atomicCAS</b> does nothing and returns
     failure. Thread B cannot enter the critical section and must loop and
     retry <b>atomicCAS(&amp;lock, 0, 1)</b> until Thread A exits the critical
     section and executes <b>lock = 0;</b>.</li>
</ol>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=0 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slides 15 &amp; 16: Visualization of _syncthreads() &amp;
atomicCAS()</b></p>

<p class=MsoNormal><b>Simple Language Explanation</b></p>

<p class=MsoNormal>These two diagrams use a timeline to visually show the
difference between the two synchronization mechanisms.</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>__syncthreads() Diagram (Slide 15):</b> Like a team
     waiting for a straggler. The fast threads (Thread 0) reach the rendezvous
     point and must wait (X) until the slowest thread (Thread 3) also arrives.
     Then, everyone proceeds together. This is a <b>collective wait</b>.</li>
 <li class=MsoNormal><b>atomicCAS() Diagram (Slide 16):</b> Like many people
     trying to go through a single-turnstile. All threads try simultaneously (<b>atomicCAS</b>).
     Only one person (Thread 0) succeeds and enters the &quot;critical
     section&quot;. The others &quot;spin-wait&quot; (X) in place. Once the
     successful person leaves, the next waiting person can go. This is <b>serial
     passage</b>.</li>
</ul>

<p class=MsoNormal><b>MCQ</b></p>

<p class=MsoNormal><b>Question:</b> Based on the visualizations, what is a key
difference between <b>__syncthreads()</b> and <b>atomicCAS()</b>? A. <b>__syncthreads()</b>
is for intra-block synchronization, while <b>atomicCAS()</b> is for global
mutual exclusion. B. <b>atomicCAS()</b> makes all threads wait together, while <b>__syncthreads()</b>
only lets one thread through. C. <b>__syncthreads()</b> is faster than <b>atomicCAS()</b>.
D. <b>atomicCAS()</b> can only be used with two threads.</p>

<p class=MsoNormal><b>Answer:</b> A</p>

<p class=MsoNormal><b>Use Cases</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>__syncthreads() Visualization Use Case:</b> When
     debugging a complex tiled algorithm, you can visualize the thread
     execution like this diagram. If your program's result is wrong, it's
     likely because you forgot an <b>__syncthreads()</b> where it was needed,
     causing some threads to read from shared memory before others had finished
     writing.</li>
 <li class=MsoNormal><b>atomicCAS() Visualization Use Case:</b> When analyzing
     the performance of a program that uses a global lock, this diagram is very
     helpful. You can see that only one thread is doing useful work while the
     others are &quot;spinning&quot; (waiting idly), which represents a
     performance overhead. If many threads are spinning, it indicates the lock
     is a bottleneck.</li>
</ol>

<p class=MsoNormal><b>Numerical Problem</b></p>

<p class=MsoNormal><b>Question:</b> A kernel has two thread blocks (Block 0 and
Block 1), each with threads. A thread in Block 0 executes <b>__syncthreads()</b>,
and a thread in Block 1 executes <b>atomicCAS</b>.</p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Will the thread in Block 0 wait for the thread in Block 1?</li>
 <li class=MsoNormal>If multiple threads within Block 0 execute <b>atomicCAS</b>
     on the same address simultaneously, what happens?</li>
</ol>

<p class=MsoNormal><b>Answer:</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>No.</b> <b>__syncthreads()</b> is a block-level
     barrier. It only synchronizes threads <i>within the same block</i>. It has
     no effect on threads in other blocks.</li>
 <li class=MsoNormal><b>Only one thread will succeed.</b> <b>atomicCAS</b> is a
     global operation. Even if multiple threads are from the same block, when
     they operate on the same global memory address simultaneously, the
     atomicity of <b>atomicCAS</b> guarantees that only one thread can
     successfully complete the &quot;compare-and-swap&quot; operation. The
     other threads will all fail and must retry.</li>
</ol>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=0 width="100%" align=center>

</div>

<p class=MsoNormal><b>Slides 17 &amp; 18: Comparisons</b></p>

<p class=MsoNormal><b>Simple Language Explanation</b></p>

<p class=MsoNormal>This slide summarizes when to use which tool.</p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>__syncthreads():</b> Use for <b>intra-team
     collaboration</b>. When you are inside a thread block and need all threads
     to complete a step (like loading data into shared memory) before the next
     step can begin, use this. It's like a coach's whistle for a team.</li>
 <li class=MsoNormal><b>atomicCAS():</b> Use for <b>contending for a unique
     global resource</b>. When multiple threads from different blocks (or even
     the same block) need exclusive access to a global variable or data
     structure, use this. It's like the single-entry gate at a popular
     attraction.</li>
</ul>

<p class=MsoNormal><b>MCQ</b></p>

<p class=MsoNormal><b>Question:</b> You are writing a CUDA kernel to perform
two tasks:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal>Divide a large array into blocks, where threads within
     each block collaborate to compute a partial sum for their section.</li>
 <li class=MsoNormal>Add all the partial sums from each block into a single
     global <b>total_sum</b> variable. Which synchronization mechanism should
     you use for task 1 and task 2, respectively? A. 1: <b>atomicCAS</b>, 2: <b>__syncthreads()</b>
     B. 1: <b>__syncthreads()</b>, 2: <b>atomicCAS</b> (or more appropriately, <b>atomicAdd</b>)
     C. Both 1 and 2 should use <b>__syncthreads()</b> D. Both 1 and 2 should
     use <b>atomicCAS</b></li>
</ol>

<p class=MsoNormal><b>Answer:</b> B</p>

<p class=MsoNormal><b>Use Cases</b></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal><b>__syncthreads() Use Cases (reiterated):</b> Tiled
     matrix multiplication, parallel reduction, image filtering (where each
     block processes an image tile and needs to synchronize on boundary
     pixels).</li>
 <li class=MsoNormal><b>atomicCAS() Use Cases (reiterated):</b> Implementing
     global mutexes, building lock-free data structures (like queues), handling
     collisions in hash tables (when multiple keys map to the same slot).</li>
</ol>

<p class=MsoNormal><b>Numerical Problem</b></p>

<p class=MsoNormal><b>Question:</b> A GPU program needs to count how many
elements in a large array are greater than 100. You decide that each thread
will check one element, and if it's greater than 100, it will use <b>atomicCAS</b>
to increment a global counter <b>count</b>. Your friend suggests that each
thread block should first count its own local total in shared memory, and then
use <b>atomicCAS</b> to add that local total to the global counter. Which
method is better and why?</p>

<p class=MsoNormal><b>Answer:</b> <b>Your friend's method is better.</b> <b>Reason:</b></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><b>Your Method:</b> If there are 1 million elements
     greater than 100, you will have 1 million threads attempting to perform an
     <b>atomicCAS</b> operation. <b>atomicCAS</b> is a global operation and is
     slow; it will cause massive contention as threads spin-wait, creating a
     serious performance bottleneck.</li>
 <li class=MsoNormal><b>Friend's Method:</b> Assume you have 1000 thread
     blocks. Threads within each block first use shared memory to quickly
     compute a local sum (this process is coordinated with <b>__syncthreads()</b>).
     Then, only 1000 threads (e.g., thread 0 from each block) perform the <b>atomicCAS</b>
     operation. This reduces the number of global atomic operations from 1
     million to 1000, dramatically reducing the performance bottleneck and
     making the program much more efficient.</li>
</ul>

<p class=MsoNormal>&nbsp;</p>

</div>

</body>

</html>
